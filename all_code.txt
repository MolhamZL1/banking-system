./.dockerignore
===== ./.dockerignore =====
node_modules
dist
coverage
.env
.git
.github
Dockerfile
docker-compose.yml
npm-debug.log
yarn.lock

./.ghaymah.json
===== ./.ghaymah.json =====
{
  "id": "2066db54-89da-412c-b075-8aa94715ad19",
  "name": "bank-app",
  "projectId": "7ba90855-ff3f-456b-b286-a90809aa0398",
  "ports": [
    {
      "expose": true,
      "number": 3000
    }
  ],
  "publicAccess": {
    "enabled": true,
    "domain": "auto"
  },
  "resourceTier": "t1",
  "dockerFileName": "Dockerfile"
}

./.github/workflows/cicd.yml
===== ./.github/workflows/cicd.yml =====
name: Test & deploy to ghaymah

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

  deploy:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push image
        run: |
          set -euo pipefail
          IMAGE="${{ secrets.DOCKERHUB_USERNAME }}/firstcicd:${{ github.sha }}"
          echo "IMAGE=$IMAGE" >> "$GITHUB_ENV"
          docker build -t "$IMAGE" .
          docker push "$IMAGE"

      - name: Install Ghaymah CLI
        run: |
          set -euo pipefail
          curl -sSl https://cli.ghaymah.systems/install.sh | bash
          test -x "$HOME/ghaymah/bin/gy"

      - name: Login to Ghaymah Cloud
        run: |
          set -euo pipefail
          "$HOME/ghaymah/bin/gy" --no-auto-update auth login \
            --email "${{ secrets.GHAYMAH_EMAIL }}" \
            --password "${{ secrets.GHAYMAH_PW }}"

      - name: Deploy (update + apply env from GitHub Secrets)
        env:
          APP_ID: ${{ secrets.GHAYMAH_APP_ID }}

          # ===== App Environment Variables =====
          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          JWT_ACCESS_EXPIRES_IN: ${{ secrets.JWT_ACCESS_EXPIRES_IN }}
          JWT_REFRESH_EXPIRES_IN: ${{ secrets.JWT_REFRESH_EXPIRES_IN }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          NODE_ENV: ${{ secrets.NODE_ENV }}
          PORT: ${{ secrets.PORT }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
        run: |
          set -euo pipefail
          echo "Deploying image: $IMAGE"

          python3 - <<'PY'
          import os, json

          payload = {
            "name": "bank-app",
            "projectId": "7ba90855-ff3f-456b-b286-a90809aa0398",
            "container": { "image": os.environ["IMAGE"] },
            "ports": [ { "expose": True, "number": 3000 } ],
            "publicAccess": { "enabled": True, "domain": "auto", "baseDomain": "hosted.ghaymah.systems" },
            "resourceTier": "t1",
            "env": {
              "ADMIN_PASSWORD": os.environ.get("ADMIN_PASSWORD",""),
              "DATABASE_URL": os.environ.get("DATABASE_URL",""),
              "JWT_ACCESS_EXPIRES_IN": os.environ.get("JWT_ACCESS_EXPIRES_IN",""),
              "JWT_REFRESH_EXPIRES_IN": os.environ.get("JWT_REFRESH_EXPIRES_IN",""),
              "JWT_SECRET": os.environ.get("JWT_SECRET",""),
              "NODE_ENV": os.environ.get("NODE_ENV","production"),
              "PORT": os.environ.get("PORT","3000"),
              "SMTP_HOST": os.environ.get("SMTP_HOST",""),
              "SMTP_PASS": os.environ.get("SMTP_PASS",""),
              "SMTP_PORT": os.environ.get("SMTP_PORT",""),
              "SMTP_USER": os.environ.get("SMTP_USER",""),
            }
          }

          with open("update.json", "w") as f:
            json.dump(payload, f)
          PY

          "$HOME/ghaymah/bin/gy" --no-auto-update resource app update "$APP_ID" --file update.json

      - name: Debug logs (only if deploy fails)
        if: failure()
        env:
          APP_ID: ${{ secrets.GHAYMAH_APP_ID }}
        run: |
          echo "=== App status ==="
          $HOME/ghaymah/bin/gy --no-auto-update resource app get "$APP_ID" || true

          echo "=== App logs (60s) ==="
          timeout 60 $HOME/ghaymah/bin/gy --no-auto-update resource app logs "$APP_ID" || true

./.gitignore
===== ./.gitignore =====
node_modules
# Keep environment variables out of version control
.env

/src/generated/prisma

./all_code.txt
===== ./all_code.txt =====

./docker-compose.yml
===== ./docker-compose.yml =====
services:
  db:
    image: postgres:16-alpine
    container_name: bank_db
    environment:
      POSTGRES_USER: appuser
      POSTGRES_PASSWORD: apppass
      POSTGRES_DB: appdb
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U appuser -d appdb"]
      interval: 5s
      timeout: 5s
      retries: 10

  api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: bank_api
    environment:
      NODE_ENV: development
      PORT: 3000
      DATABASE_URL: postgres://appuser:apppass@db:5432/appdb
      ADMIN_PASSWORD: "123456"

      JWT_SECRET: "ee537f503a31c9ab857d0ebbfb01514b8acbc55c9a624fe285f1ddc24c0ef80d"
      JWT_ACCESS_EXPIRES_IN: "15m"
      JWT_REFRESH_EXPIRES_IN: "30d"

      SMTP_HOST: "smtp.gmail.com"
      SMTP_PORT: "587"
      SMTP_USER: "molhamsa49@gmail.com"
      SMTP_PASS: "agnp ntss wygk hsiy"
    ports:
      - "3000:3000"
    depends_on:
      db:
        condition: service_healthy
    command: sh -c "npx prisma migrate dev --name init && node dist/server.js"

volumes:
  pgdata:

./Dockerfile
===== ./Dockerfile =====
# 1) Base
FROM node:20-alpine

# 2) Workdir
WORKDIR /app

# 3) Install deps
COPY package*.json ./
RUN npm ci

# 4) Copy source
COPY . .

# 5) Prisma generate (needs schema.prisma)
RUN npx prisma generate

# 6) Build TS -> dist
RUN npm run build

# 7) Runtime
EXPOSE 3000
CMD ["npm", "run", "start"]

./jest.config.js
===== ./jest.config.js =====
/** @type {import("jest").Config} */
module.exports = {
  preset: "ts-jest",
  testEnvironment: "node",
  testMatch: ["**/__tests__/**/*.test.ts"],
  setupFilesAfterEnv: ["<rootDir>/src/__tests__/setup.ts"],

  collectCoverage: true,
  collectCoverageFrom: [
    "src/**/*.ts",
    "!src/server.ts",
    "!src/infrastructure/prisma/**",
    "!src/infrastructure/mailer/**",
    "!src/__tests__/**",
  ],
  // coverageThreshold: {
  //   global: { statements: 70, branches: 70, functions: 70, lines: 70 },
  // },

  coverageDirectory: "coverage",
  coverageReporters: ["text", "lcov"],

  // مؤقتاً نخلي threshold يتفعل بعد ما يشتغل التست
  // (رجّعه 70 بعد ما يصير عندك coverage حقيقي)
  // coverageThreshold: {
  //   global: { statements: 70, branches: 70, functions: 70, lines: 70 },
  // },
};

./package.json
===== ./package.json =====
{
  "name": "advanced-banking-system",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "prisma:init": "prisma init --datasource-provider postgresql",
    "prisma:migrate": "prisma migrate dev",
    "prisma:generate": "prisma generate",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:cov:open": "python3 -c \"print(\\\"Open coverage/lcov-report/index.html\\\")\""
  },
  "prisma": {
    "seed": "tsx src/infrastructure/prisma/seed.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@prisma/client": "^6.15.0",
    "bcrypt": "^6.0.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.3",
    "morgan": "^1.10.1",
    "node-cron": "^4.2.1",
    "nodemailer": "^7.0.11",
    "zod": "^4.1.13"
  },
  "devDependencies": {
    "@types/bcrypt": "^6.0.0",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.6",
    "@types/jest": "^30.0.0",
    "@types/morgan": "^1.9.10",
    "@types/node": "^24.10.2",
    "@types/nodemailer": "^7.0.4",
    "@types/supertest": "^6.0.3",
    "cross-env": "^10.1.0",
    "jest": "^30.2.0",
    "prisma": "^6.15.0",
    "supertest": "^7.1.4",
    "ts-jest": "^29.4.6",
    "ts-node-dev": "^2.0.0",
    "tsx": "^4.21.0",
    "typescript": "^5.9.3"
  }
}

./prisma/migrations/20251211111452_init_schema/migration.sql
===== ./prisma/migrations/20251211111452_init_schema/migration.sql =====
-- CreateEnum
CREATE TYPE "Role" AS ENUM ('CUSTOMER', 'TELLER', 'MANAGER', 'ADMIN');

-- CreateEnum
CREATE TYPE "AccountType" AS ENUM ('SAVINGS', 'CHECKING', 'LOAN', 'INVESTMENT');

-- CreateEnum
CREATE TYPE "AccountState" AS ENUM ('ACTIVE', 'FROZEN', 'SUSPENDED', 'CLOSED');

-- CreateEnum
CREATE TYPE "TransactionType" AS ENUM ('DEPOSIT', 'WITHDRAWAL', 'TRANSFER');

-- CreateEnum
CREATE TYPE "TransactionStatus" AS ENUM ('PENDING', 'COMPLETED', 'FAILED');

-- CreateEnum
CREATE TYPE "TicketStatus" AS ENUM ('OPEN', 'IN_PROGRESS', 'CLOSED');

-- CreateEnum
CREATE TYPE "NotificationChannel" AS ENUM ('EMAIL', 'SMS', 'IN_APP');

-- CreateEnum
CREATE TYPE "NotificationStatus" AS ENUM ('PENDING', 'SENT', 'FAILED');

-- CreateEnum
CREATE TYPE "Frequency" AS ENUM ('DAILY', 'WEEKLY', 'MONTHLY');

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "username" TEXT NOT NULL,
    "passwordHash" TEXT NOT NULL,
    "email" TEXT,
    "phone" TEXT,
    "role" "Role" NOT NULL DEFAULT 'CUSTOMER',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Account" (
    "id" SERIAL NOT NULL,
    "userId" INTEGER NOT NULL,
    "accountType" "AccountType" NOT NULL,
    "balance" DECIMAL(65,30) NOT NULL DEFAULT 0.0,
    "state" "AccountState" NOT NULL DEFAULT 'ACTIVE',
    "parentAccountId" INTEGER,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Account_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Transaction" (
    "id" SERIAL NOT NULL,
    "fromAccountId" INTEGER,
    "toAccountId" INTEGER,
    "amount" DECIMAL(65,30) NOT NULL,
    "type" "TransactionType" NOT NULL,
    "status" "TransactionStatus" NOT NULL DEFAULT 'PENDING',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "approvedById" INTEGER,

    CONSTRAINT "Transaction_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ScheduledTransaction" (
    "id" SERIAL NOT NULL,
    "fromAccountId" INTEGER,
    "toAccountId" INTEGER,
    "amount" DECIMAL(65,30) NOT NULL,
    "type" "TransactionType" NOT NULL,
    "frequency" "Frequency" NOT NULL,
    "nextRunAt" TIMESTAMP(3) NOT NULL,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "ScheduledTransaction_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Ticket" (
    "id" SERIAL NOT NULL,
    "userId" INTEGER NOT NULL,
    "subject" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "status" "TicketStatus" NOT NULL DEFAULT 'OPEN',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Ticket_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Notification" (
    "id" SERIAL NOT NULL,
    "userId" INTEGER NOT NULL,
    "relatedAccountId" INTEGER,
    "relatedTransactionId" INTEGER,
    "channel" "NotificationChannel" NOT NULL,
    "message" TEXT NOT NULL,
    "status" "NotificationStatus" NOT NULL DEFAULT 'PENDING',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "sentAt" TIMESTAMP(3),

    CONSTRAINT "Notification_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "EventLog" (
    "id" SERIAL NOT NULL,
    "userId" INTEGER,
    "accountId" INTEGER,
    "transactionId" INTEGER,
    "eventType" TEXT NOT NULL,
    "details" JSONB,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "EventLog_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_username_key" ON "User"("username");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- AddForeignKey
ALTER TABLE "Account" ADD CONSTRAINT "Account_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Account" ADD CONSTRAINT "Account_parentAccountId_fkey" FOREIGN KEY ("parentAccountId") REFERENCES "Account"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Transaction" ADD CONSTRAINT "Transaction_fromAccountId_fkey" FOREIGN KEY ("fromAccountId") REFERENCES "Account"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Transaction" ADD CONSTRAINT "Transaction_toAccountId_fkey" FOREIGN KEY ("toAccountId") REFERENCES "Account"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Transaction" ADD CONSTRAINT "Transaction_approvedById_fkey" FOREIGN KEY ("approvedById") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ScheduledTransaction" ADD CONSTRAINT "ScheduledTransaction_fromAccountId_fkey" FOREIGN KEY ("fromAccountId") REFERENCES "Account"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ScheduledTransaction" ADD CONSTRAINT "ScheduledTransaction_toAccountId_fkey" FOREIGN KEY ("toAccountId") REFERENCES "Account"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Ticket" ADD CONSTRAINT "Ticket_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Notification" ADD CONSTRAINT "Notification_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Notification" ADD CONSTRAINT "Notification_relatedAccountId_fkey" FOREIGN KEY ("relatedAccountId") REFERENCES "Account"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Notification" ADD CONSTRAINT "Notification_relatedTransactionId_fkey" FOREIGN KEY ("relatedTransactionId") REFERENCES "Transaction"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "EventLog" ADD CONSTRAINT "EventLog_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "EventLog" ADD CONSTRAINT "EventLog_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "Account"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "EventLog" ADD CONSTRAINT "EventLog_transactionId_fkey" FOREIGN KEY ("transactionId") REFERENCES "Transaction"("id") ON DELETE SET NULL ON UPDATE CASCADE;

./prisma/migrations/20251216150013_/migration.sql
===== ./prisma/migrations/20251216150013_/migration.sql =====
-- AlterTable
ALTER TABLE "public"."User" ADD COLUMN     "isEmailVerified" BOOLEAN NOT NULL DEFAULT false;

-- CreateTable
CREATE TABLE "public"."RefreshToken" (
    "id" SERIAL NOT NULL,
    "userId" INTEGER NOT NULL,
    "tokenHash" TEXT NOT NULL,
    "revokedAt" TIMESTAMP(3),
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "RefreshToken_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."EmailVerification" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "codeHash" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "usedAt" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "EmailVerification_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "RefreshToken_tokenHash_key" ON "public"."RefreshToken"("tokenHash");

-- CreateIndex
CREATE INDEX "RefreshToken_userId_idx" ON "public"."RefreshToken"("userId");

-- CreateIndex
CREATE INDEX "EmailVerification_email_idx" ON "public"."EmailVerification"("email");

-- AddForeignKey
ALTER TABLE "public"."RefreshToken" ADD CONSTRAINT "RefreshToken_userId_fkey" FOREIGN KEY ("userId") REFERENCES "public"."User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

./prisma/migrations/20251217184059_add_group_account_type/migration.sql
===== ./prisma/migrations/20251217184059_add_group_account_type/migration.sql =====
-- AlterEnum
ALTER TYPE "public"."AccountType" ADD VALUE 'GROUP';

./prisma/migrations/20251217184816_name/migration.sql
===== ./prisma/migrations/20251217184816_name/migration.sql =====
/*
  Warnings:

  - Added the required column `name` to the `Account` table without a default value. This is not possible if the table is not empty.

*/
-- AlterTable
ALTER TABLE "public"."Account" ADD COLUMN     "name" TEXT NOT NULL;

./prisma/migrations/20251219120553_add_account_features/migration.sql
===== ./prisma/migrations/20251219120553_add_account_features/migration.sql =====
-- CreateEnum
CREATE TYPE "public"."AccountFeatureType" AS ENUM ('PREMIUM', 'INSURANCE', 'OVERDRAFT_PLUS');

-- CreateTable
CREATE TABLE "public"."AccountFeature" (
    "id" SERIAL NOT NULL,
    "accountId" INTEGER NOT NULL,
    "type" "public"."AccountFeatureType" NOT NULL,
    "numberValue" DECIMAL(65,30),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "AccountFeature_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "AccountFeature_accountId_idx" ON "public"."AccountFeature"("accountId");

-- CreateIndex
CREATE UNIQUE INDEX "AccountFeature_accountId_type_key" ON "public"."AccountFeature"("accountId", "type");

-- AddForeignKey
ALTER TABLE "public"."AccountFeature" ADD CONSTRAINT "AccountFeature_accountId_fkey" FOREIGN KEY ("accountId") REFERENCES "public"."Account"("id") ON DELETE CASCADE ON UPDATE CASCADE;

./prisma/migrations/20251219161445_add_missing_modules/migration.sql
===== ./prisma/migrations/20251219161445_add_missing_modules/migration.sql =====
/*
  Warnings:

  - Added the required column `createdById` to the `ScheduledTransaction` table without a default value. This is not possible if the table is not empty.

*/
-- AlterTable
ALTER TABLE "public"."Notification" ADD COLUMN     "readAt" TIMESTAMP(3);

-- AlterTable
ALTER TABLE "public"."ScheduledTransaction" ADD COLUMN     "createdById" INTEGER NOT NULL;

-- CreateIndex
CREATE INDEX "EventLog_userId_idx" ON "public"."EventLog"("userId");

-- CreateIndex
CREATE INDEX "EventLog_accountId_idx" ON "public"."EventLog"("accountId");

-- CreateIndex
CREATE INDEX "EventLog_transactionId_idx" ON "public"."EventLog"("transactionId");

-- CreateIndex
CREATE INDEX "Notification_userId_idx" ON "public"."Notification"("userId");

-- CreateIndex
CREATE INDEX "ScheduledTransaction_createdById_idx" ON "public"."ScheduledTransaction"("createdById");

-- AddForeignKey
ALTER TABLE "public"."ScheduledTransaction" ADD CONSTRAINT "ScheduledTransaction_createdById_fkey" FOREIGN KEY ("createdById") REFERENCES "public"."User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

./prisma/migrations/migration_lock.toml
===== ./prisma/migrations/migration_lock.toml =====
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"

./prisma/schema.prisma
===== ./prisma/schema.prisma =====
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              Int      @id @default(autoincrement())
  username        String   @unique
  passwordHash    String
  email           String?  @unique
  phone           String?
  role            Role     @default(CUSTOMER)
  isEmailVerified Boolean  @default(false)
  createdAt       DateTime @default(now())

  accounts        Account[]
  tickets         Ticket[]
  notifications   Notification[]
  events          EventLog[]
  approvedTransactions Transaction[] @relation("ApprovedBy")
  refreshTokens   RefreshToken[]

  scheduledTransactions ScheduledTransaction[] @relation("ScheduledBy")
}

model RefreshToken {
  id         Int      @id @default(autoincrement())
  userId     Int
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  tokenHash  String   @unique
  revokedAt  DateTime?
  expiresAt  DateTime
  createdAt  DateTime @default(now())

  @@index([userId])
}

model EmailVerification {
  id         Int      @id @default(autoincrement())
  email      String
  codeHash   String
  expiresAt  DateTime
  usedAt     DateTime?
  createdAt  DateTime @default(now())

  @@index([email])
}

model Account {
  id              Int          @id @default(autoincrement())
  userId          Int
  user            User         @relation(fields: [userId], references: [id])
  accountType     AccountType
  name            String
  balance         Decimal      @default(0.0)
  state           AccountState @default(ACTIVE)
  parentAccountId Int?
  parentAccount   Account?     @relation("AccountHierarchy", fields: [parentAccountId], references: [id])
  subAccounts     Account[]    @relation("AccountHierarchy")
  createdAt       DateTime     @default(now())

  features        AccountFeature[]

  transactionsFrom Transaction[] @relation("FromAccount")
  transactionsTo   Transaction[] @relation("ToAccount")
  scheduledFrom    ScheduledTransaction[] @relation("ScheduledFrom")
  scheduledTo      ScheduledTransaction[] @relation("ScheduledTo")
  notifications    Notification[]
  events           EventLog[]
}

model AccountFeature {
  id          Int @id @default(autoincrement())
  accountId   Int
  account     Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  type        AccountFeatureType
  numberValue Decimal?
  createdAt   DateTime @default(now())

  @@unique([accountId, type])
  @@index([accountId])
}

model Transaction {
  id            Int               @id @default(autoincrement())
  fromAccountId Int?
  fromAccount   Account?          @relation("FromAccount", fields: [fromAccountId], references: [id])
  toAccountId   Int?
  toAccount     Account?          @relation("ToAccount", fields: [toAccountId], references: [id])

  amount        Decimal
  type          TransactionType
  status        TransactionStatus @default(PENDING)
  createdAt     DateTime          @default(now())

  approvedById  Int?
  approvedBy    User?             @relation("ApprovedBy", fields: [approvedById], references: [id])

  notifications Notification[]
  events        EventLog[]
}

model ScheduledTransaction {
  id            Int       @id @default(autoincrement())
  fromAccountId Int?
  fromAccount   Account?  @relation("ScheduledFrom", fields: [fromAccountId], references: [id])
  toAccountId   Int?
  toAccount     Account?  @relation("ScheduledTo", fields: [toAccountId], references: [id])

  createdById   Int
  createdBy     User      @relation("ScheduledBy", fields: [createdById], references: [id], onDelete: Cascade)

  amount        Decimal
  type          TransactionType
  frequency     Frequency
  nextRunAt     DateTime
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())

  @@index([createdById])
}

model Ticket {
  id          Int          @id @default(autoincrement())
  userId      Int
  user        User         @relation(fields: [userId], references: [id])

  subject     String
  description String
  status      TicketStatus @default(OPEN)

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

model Notification {
  id                   Int           @id @default(autoincrement())
  userId               Int
  user                 User          @relation(fields: [userId], references: [id])

  relatedAccountId     Int?
  relatedAccount       Account?      @relation(fields: [relatedAccountId], references: [id])

  relatedTransactionId Int?
  relatedTransaction   Transaction?  @relation(fields: [relatedTransactionId], references: [id])

  channel              NotificationChannel
  message              String
  status               NotificationStatus @default(PENDING)
  createdAt            DateTime      @default(now())
  sentAt               DateTime?

  readAt               DateTime?

  @@index([userId])
}

model EventLog {
  id             Int        @id @default(autoincrement())
  userId         Int?
  user           User?      @relation(fields: [userId], references: [id])
  accountId      Int?
  account        Account?   @relation(fields: [accountId], references: [id])
  transactionId  Int?
  transaction    Transaction? @relation(fields: [transactionId], references: [id])
  eventType      String
  details        Json?
  createdAt      DateTime   @default(now())

  @@index([userId])
  @@index([accountId])
  @@index([transactionId])
}

enum AccountFeatureType {
  PREMIUM
  INSURANCE
  OVERDRAFT_PLUS
}

enum Role {
  CUSTOMER
  TELLER
  MANAGER
  ADMIN
}

enum AccountType {
  SAVINGS
  CHECKING
  LOAN
  INVESTMENT
  GROUP
}

enum AccountState {
  ACTIVE
  FROZEN
  SUSPENDED
  CLOSED
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  TRANSFER
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  CLOSED
}

enum NotificationChannel {
  EMAIL
  SMS
  IN_APP
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
}

enum Frequency {
  DAILY
  WEEKLY
  MONTHLY
}

./README.md
===== ./README.md =====
# Bank API Documentation (Quick)

### App url : https://bank-app-fcf3e0266562.hosted.ghaymah.systems/

### API collection : https://web.postman.co/workspace/My-Workspace~c0395906-0a62-4dd1-83c1-7d9cc2c3e262/collection/31065407-57c2c3e8-f92e-457d-bb8d-84da34072bcc?action=share&source=copy-link&creator=31065407

## Diagrams (UML)

All diagrams are stored under:

- `uml/` → Class and Sequence diagrams for design patterns used in the syste

### Class Diagrams (Design Patterns)

![](uml/01-composite.png)
![](uml/02-decorator.png)
![](uml/04-strategy.png)
![](uml/03-observer.png)
![](uml/05-chain-of-responsibility.png)
![](uml/06-state.png)

### Sequence Diagrams

![](uml/01-observer-create-account.png)
![](uml/02-state-change-account-state.png)
![](uml/03-composite-create-group.png)
![](uml/04-decorator-add-features.png)
![](uml/05-strategy-interest-calculation.png)
![](uml/06-cor-transaction-approval.png)

---

## Auth

- `POST /api/auth/register` create customer (email not verified yet)
- `POST /api/auth/resend-code` resend verification code
- `POST /api/auth/verify-email` verify email; returns tokens
- `POST /api/auth/login` returns tokens
- `POST /api/auth/refresh` rotates refresh token; returns new tokens
- `POST /api/auth/logout`
- `GET /api/auth/me` (Bearer)

## Accounts

- `GET /api/accounts` list accounts (Customer: own; Staff can add `?userId=ID`)
- `GET /api/accounts/search` search/filter accounts (auth required)
- `POST /api/accounts/create` (ADMIN/TELLER) create account
- `GET /api/accounts/:id` get account
- `PATCH /api/accounts/:id/rename` rename account
- `PATCH /api/accounts/state/:id` (ADMIN/TELLER) state action: FREEZE|SUSPEND|ACTIVATE|CLOSE
- **Decorator Features**
  - `POST /api/accounts/:id/features` add feature: PREMIUM|INSURANCE|OVERDRAFT_PLUS
  - `DELETE /api/accounts/:id/features/:type` remove feature
- **Composite Groups**
  - `POST /api/accounts/groups/create` create group with childAccountIds
  - `POST /api/accounts/groups/:groupId/children` add child
  - `DELETE /api/accounts/groups/:groupId/children/:childId` remove child

## Transactions

- `POST /api/transactions` create transaction (DEPOSIT/WITHDRAWAL/TRANSFER). May be PENDING if approval needed.
- `GET /api/transactions/pending` (ADMIN/TELLER/MANAGER) list pending
- `PATCH /api/transactions/:id/approve` (ADMIN/TELLER/MANAGER) approve
- `PATCH /api/transactions/:id/reject` (ADMIN/TELLER/MANAGER) reject

## Scheduled Transactions

- `POST /api/scheduled-transactions` create (frequency DAILY/WEEKLY/MONTHLY)
- `GET /api/scheduled-transactions` list mine
- `PATCH /api/scheduled-transactions/:id/stop`
- `PATCH /api/scheduled-transactions/:id/resume`

## Notifications

- `GET /api/notifications` list mine
- `PATCH /api/notifications/:id/read` mark read

## Tickets

- `POST /api/tickets` create
- `GET /api/tickets` list (Customer: own; Staff: all)
- `PATCH /api/tickets/:id/status` (ADMIN/TELLER/MANAGER) set status OPEN|IN_PROGRESS|CLOSED

## Events

- `GET /api/events` list (Customer: own; Staff can add `?userId=ID`)

## Admin

./src/api/controllers/account.controller.ts
===== ./src/api/controllers/account.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import { AccountsService } from '../../application/services/accounts.service';

export class AccountController {
  constructor(private readonly service: AccountsService) {}

  create = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const acc = await this.service.createAccount(req.body);
      res.status(201).json({ success: true, data: acc });
    } catch (e) { next(e); }
  };

  listMine = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const userIdParam = req.query.userId ? Number(req.query.userId) : undefined;
      const out = await this.service.listAccountsApi({ userId: req.auth!.userId, role: req.auth!.role }, userIdParam);
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  getById = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const acc = await this.service.getAccount(Number(req.params.id));
      res.json({ success: true, data: acc });
    } catch (e) { next(e); }
  };

  rename = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.renameAccountApi(
        { userId: req.auth!.userId, role: req.auth!.role },
        Number(req.params.id),
        req.body.newName
      );
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  changeState = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const updated = await this.service.changeState(Number(req.params.id), req.body.action);
      res.json({ success: true, data: updated });
    } catch (e) { next(e); }
  };

  addFeature = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.addFeature(Number(req.params.id), req.body);
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  removeFeature = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.removeFeature(Number(req.params.id), req.params.type as any);
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  createGroup = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const group = await this.service.createAccountGroup({
        userId: req.auth!.userId,
        name: req.body.name,
        childAccountIds: req.body.childAccountIds ?? [],
      });
      res.status(201).json({ success: true, data: group });
    } catch (e) { next(e); }
  };

  addToGroup = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const result = await this.service.addToGroup(
        Number(req.params.groupId),
        Number(req.body.childAccountId)
      );
      res.json({ success: true, ...result });
    } catch (e) { next(e); }
  };

  removeFromGroup = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const result = await this.service.removeFromGroup(
        Number(req.params.groupId),
        Number(req.params.childId)
      );
      res.json({ success: true, ...result });
    } catch (e) { next(e); }
  };

  search = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const filters = {
        userId: req.query.userId ? Number(req.query.userId) : undefined,
        accountType: req.query.accountType as any,
        state: req.query.state as string,
        minBalance: req.query.minBalance ? Number(req.query.minBalance) : undefined,
        maxBalance: req.query.maxBalance ? Number(req.query.maxBalance) : undefined,
      };
      const results = await this.service.searchAccounts(filters);
      res.json({ success: true, data: results });
    } catch (e) { next(e); }
  };
}

./src/api/controllers/admin.controller.ts
===== ./src/api/controllers/admin.controller.ts =====
import { Request, Response, NextFunction } from "express";
import { AdminService } from "../../application/services/admin.service";

export class AdminController {
  constructor(private readonly service: AdminService) {}

  dashboard = async (_req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.dashboard();
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  dailyTx = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.dailyTx(req.query.date as string | undefined);
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  accountsSummary = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.accountsSummary({
        userId: req.query.userId ? Number(req.query.userId) : undefined,
        type: req.query.type as string | undefined,
        state: req.query.state as string | undefined,
      });
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  audit = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.audit({
        from: req.query.from as string | undefined,
        to: req.query.to as string | undefined,
        userId: req.query.userId ? Number(req.query.userId) : undefined,
        eventType: req.query.eventType as string | undefined,
      });
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };
}

./src/api/controllers/auth.controller.ts
===== ./src/api/controllers/auth.controller.ts =====
import { Request, Response, NextFunction } from 'express';
import { AuthService } from '../../application/services/auth.service';

const service = new AuthService();

export class AuthController {

   static createStaff = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await service.createStaff(req.body);
      res.status(201).json({ success: true, data: out });
    } catch (e) { next(e); }
  };
  
  static register = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await service.register(req.body);
      res.status(201).json({ success: true, data: out });
    } catch (e) { next(e); }
  };


  static resendCode = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await service.resendCode(req.body.email);
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  static verifyEmail = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await service.verifyEmail(req.body);
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  static login = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await service.login(req.body);
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  static refresh = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await service.refresh(req.body.refreshToken);
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  static logout = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await service.logout(req.body.refreshToken);
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  static me = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await service.me(req.auth!.userId);
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };
}

./src/api/controllers/events.controller.ts
===== ./src/api/controllers/events.controller.ts =====
import { Request, Response, NextFunction } from "express";
import { EventsService } from "../../application/services/events.service";

export class EventsController {
  constructor(private readonly service = new EventsService()) {}

  list = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const userId = req.query.userId ? Number(req.query.userId) : undefined;
      const out = await this.service.list(
        { userId: req.auth!.userId, role: req.auth!.role },
        userId ? { userId } : undefined
      );
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };
}

./src/api/controllers/notifications.controller.ts
===== ./src/api/controllers/notifications.controller.ts =====
import { Request, Response, NextFunction } from "express";
import { NotificationsService } from "../../application/services/notifications.service";

export class NotificationsController {
  constructor(private readonly service = new NotificationsService()) {}

  list = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.list(req.auth!.userId);
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  read = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.markRead(req.auth!.userId, Number(req.params.id));
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };
}

./src/api/controllers/scheduledTransaction.controller.ts
===== ./src/api/controllers/scheduledTransaction.controller.ts =====
import { Request, Response, NextFunction } from "express";
import { ScheduledTransactionsService } from "../../application/services/scheduledTransactions.service";

export class ScheduledTransactionController {
  constructor(private readonly service = new ScheduledTransactionsService()) {}

  create = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.create({ userId: req.auth!.userId }, req.body);
      res.status(201).json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  list = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.list({ userId: req.auth!.userId });
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  stop = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.stop({ userId: req.auth!.userId }, Number(req.params.id));
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  resume = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.resume({ userId: req.auth!.userId }, Number(req.params.id));
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };
}

./src/api/controllers/ticket.controller.ts
===== ./src/api/controllers/ticket.controller.ts =====
import { Request, Response, NextFunction } from "express";
import { TicketsService } from "../../application/services/tickets.service";

export class TicketController {
  constructor(private readonly service = new TicketsService()) {}

  create = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.create(req.auth!.userId, req.body);
      res.status(201).json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  list = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.list({ userId: req.auth!.userId, role: req.auth!.role });
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  setStatus = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.setStatus(
        { role: req.auth!.role },
        Number(req.params.id),
        req.body.status
      );
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };
}

./src/api/controllers/transaction.controller.ts
===== ./src/api/controllers/transaction.controller.ts =====
import { Request, Response, NextFunction } from "express";
import { TransactionsService } from "../../application/services/transactions.service";

export class TransactionController {
  constructor(private readonly service: TransactionsService) {}

  create = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.create({
        ...req.body,
        requester: { userId: req.auth!.userId, role: req.auth!.role },
      });
      res.status(201).json({ success: true, data: out });
    } catch (e) {
      next(e);
    }
  };

  pending = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.pending({ role: req.auth!.role });
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  approve = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.approve({ userId: req.auth!.userId, role: req.auth!.role }, Number(req.params.id));
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };

  reject = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const out = await this.service.reject({ userId: req.auth!.userId, role: req.auth!.role }, Number(req.params.id), req.body?.reason);
      res.json({ success: true, data: out });
    } catch (e) { next(e); }
  };
}

./src/api/middleware/auth.middleware.ts
===== ./src/api/middleware/auth.middleware.ts =====
import { Request, Response, NextFunction } from 'express';
import { verifyToken } from '../../infrastructure/auth/jwt';
import { HttpError } from '../../application/errors/http-error';

declare global {
  namespace Express {
    interface Request {
      auth?: { userId: number; role: string };
    }
  }
}

export function requireAuth(req: Request, _res: Response, next: NextFunction) {
  const header = req.headers.authorization;
  if (!header?.startsWith('Bearer ')) return next(new HttpError(401, 'Missing Bearer token'));

  const token = header.slice('Bearer '.length);
  try {
    const payload = verifyToken(token);
    req.auth = { userId: payload.userId, role: payload.role };
    next();
  } catch {
    next(new HttpError(401, 'Invalid token'));
  }
}

export function requireRoles(...roles: string[]) {
  return (req: Request, _res: Response, next: NextFunction) => {
    if (!req.auth) return next(new HttpError(401, 'Unauthorized'));
    if (!roles.includes(req.auth.role)) return next(new HttpError(403, 'Forbidden'));
    next();
  };
}

./src/api/middleware/errorHandler.ts
===== ./src/api/middleware/errorHandler.ts =====
import { Request, Response, NextFunction } from 'express';

export function errorHandler(
  err: any,
  req: Request,
  res: Response,
  next: NextFunction
) {
  console.error('❌ Error:', err);

  const status = err.status || 500;
  const message = err.message || 'Internal Server Error';

  res.status(status).json({
    success: false,
    message
  });
}

./src/api/middleware/validateRequest.ts
===== ./src/api/middleware/validateRequest.ts =====
import { Request, Response, NextFunction } from 'express';
import { ZodSchema } from 'zod';
import { HttpError } from '../../application/errors/http-error';

export const validateBody =
  (schema: ZodSchema) => (req: Request, _res: Response, next: NextFunction) => {
    
    const parsed = schema.safeParse(req.body);
    if (!parsed.success) {
      return next(new HttpError(400, JSON.stringify(parsed.error.issues)));
    }

    req.body = parsed.data;
    next();
  };

./src/api/routes/account.routes.ts
===== ./src/api/routes/account.routes.ts =====
import { Router } from 'express';
import { AccountController } from '../controllers/account.controller';
import { AccountsService } from '../../application/services/accounts.service';
import { AccountRepo } from '../../repositories/account.repo';
import { requireAuth, requireRoles } from '../middleware/auth.middleware';
import { validateBody } from '../middleware/validateRequest';
import { CreateAccountSchema, ChangeStateSchema, CreateAccountGroupSchema, RenameAccountSchema } from '../validators/account.validation';
import { AddFeatureSchema } from '../validators/account.features.validation';
import { buildNotificationCenter } from '../../application/notifications/notification.wiring';

const router = Router();

const repo = new AccountRepo();
const notificationCenter = buildNotificationCenter();
const service = new AccountsService(repo, notificationCenter);
const controller = new AccountController(service);

// البحث
router.get('/search', requireAuth, controller.search);

// list
router.get('/', requireAuth, controller.listMine);

// الحسابات
router.post('/create', requireAuth, requireRoles('ADMIN', 'TELLER'), validateBody(CreateAccountSchema), controller.create);
router.get('/:id', requireAuth, controller.getById);
router.patch('/:id/rename', requireAuth, validateBody(RenameAccountSchema), controller.rename);
router.patch('/state/:id', requireAuth, requireRoles('ADMIN', 'TELLER'), validateBody(ChangeStateSchema), controller.changeState);

// Decorator Features
router.post('/:id/features', requireAuth, validateBody(AddFeatureSchema), controller.addFeature);
router.delete('/:id/features/:type', requireAuth, controller.removeFeature);

// المجموعات
router.post('/groups/create', requireAuth, requireRoles('CUSTOMER'), validateBody(CreateAccountGroupSchema), controller.createGroup);
router.post('/groups/:groupId/children', requireAuth, controller.addToGroup);
router.delete('/groups/:groupId/children/:childId', requireAuth, controller.removeFromGroup);

export default router;

./src/api/routes/admin.routes.ts
===== ./src/api/routes/admin.routes.ts =====
import { Router } from "express";
import { requireAuth, requireRoles } from "../middleware/auth.middleware";
import { AdminService } from "../../application/services/admin.service";
import { AdminController } from "../controllers/admin.controller";

const router = Router();

const service = new AdminService();
const controller = new AdminController(service);

// Dashboard (monitoring)
router.get("/dashboard", requireAuth, requireRoles("ADMIN", "MANAGER"), controller.dashboard);

// Reports
router.get("/reports/transactions/daily", requireAuth, requireRoles("ADMIN", "MANAGER"), controller.dailyTx);
router.get("/reports/accounts/summary", requireAuth, requireRoles("ADMIN", "MANAGER"), controller.accountsSummary);
router.get("/reports/audit", requireAuth, requireRoles("ADMIN", "MANAGER"), controller.audit);

export default router;

./src/api/routes/auth.routes.ts
===== ./src/api/routes/auth.routes.ts =====
import { Router } from 'express';
import { AuthController } from '../controllers/auth.controller';
import { validateBody } from '../middleware/validateRequest';
import { requireAuth, requireRoles } from '../middleware/auth.middleware';
import { RegisterSchema, ResendCodeSchema, VerifyEmailSchema, LoginSchema, RefreshSchema, CreateStaffSchema } from '../validators/auth.validators';

const router = Router();

router.post('/register', validateBody(RegisterSchema), AuthController.register);
router.post('/create-staff', requireAuth, requireRoles('ADMIN') ,validateBody(CreateStaffSchema), AuthController.createStaff);
router.post('/resend-code', validateBody(ResendCodeSchema), AuthController.resendCode);
router.post('/verify-email', validateBody(VerifyEmailSchema), AuthController.verifyEmail);

router.post('/login', validateBody(LoginSchema), AuthController.login);
router.post('/refresh', validateBody(RefreshSchema), AuthController.refresh);
router.post('/logout', validateBody(RefreshSchema), AuthController.logout);

router.get('/me', requireAuth, AuthController.me);

export default router;

./src/api/routes/events.routes.ts
===== ./src/api/routes/events.routes.ts =====
import { Router } from "express";
import { requireAuth } from "../middleware/auth.middleware";
import { EventsController } from "../controllers/events.controller";

const router = Router();
const c = new EventsController();

router.get("/", requireAuth, c.list);

export default router;

./src/api/routes/index.ts
===== ./src/api/routes/index.ts =====
import adminRoutes from "./admin.routes";
import { Router } from 'express';
import accountRoutes from './account.routes';
import authRoutes from './auth.routes';
import transactionRoutes from './transaction.routes';
import notificationRoutes from './notifications.routes';
import ticketRoutes from './ticket.routes';
import eventsRoutes from './events.routes';
import scheduledRoutes from './scheduledTransaction.routes';

const router = Router();

router.get('/health', (req, res) => res.json({ status: 'ok' }));

router.use('/auth', authRoutes);
router.use('/accounts', accountRoutes);
router.use('/transactions', transactionRoutes);
router.use('/admin', adminRoutes);

router.use('/notifications', notificationRoutes);
router.use('/tickets', ticketRoutes);
router.use('/events', eventsRoutes);
router.use('/scheduled-transactions', scheduledRoutes);

export default router;

./src/api/routes/notifications.routes.ts
===== ./src/api/routes/notifications.routes.ts =====
import { Router } from "express";
import { requireAuth } from "../middleware/auth.middleware";
import { NotificationsController } from "../controllers/notifications.controller";

const router = Router();
const c = new NotificationsController();

router.get("/", requireAuth, c.list);
router.patch("/:id/read", requireAuth, c.read);

export default router;

./src/api/routes/scheduledTransaction.routes.ts
===== ./src/api/routes/scheduledTransaction.routes.ts =====
import { Router } from "express";
import { requireAuth } from "../middleware/auth.middleware";
import { validateBody } from "../middleware/validateRequest";
import { ScheduledTransactionController } from "../controllers/scheduledTransaction.controller";
import { CreateScheduledTxSchema } from "../validators/scheduledTransaction.validation";

const router = Router();
const c = new ScheduledTransactionController();

router.post("/", requireAuth, validateBody(CreateScheduledTxSchema), c.create);
router.get("/", requireAuth, c.list);
router.patch("/:id/stop", requireAuth, c.stop);
router.patch("/:id/resume", requireAuth, c.resume);

export default router;

./src/api/routes/ticket.routes.ts
===== ./src/api/routes/ticket.routes.ts =====
import { Router } from "express";
import { requireAuth, requireRoles } from "../middleware/auth.middleware";
import { validateBody } from "../middleware/validateRequest";
import { TicketController } from "../controllers/ticket.controller";
import { CreateTicketSchema, UpdateTicketStatusSchema } from "../validators/ticket.validation";

const router = Router();
const c = new TicketController();

router.post("/", requireAuth, validateBody(CreateTicketSchema), c.create);
router.get("/", requireAuth, c.list);

// Staff only
router.patch("/:id/status", requireAuth, requireRoles("ADMIN", "TELLER", "MANAGER"), validateBody(UpdateTicketStatusSchema), c.setStatus);

export default router;

./src/api/routes/transaction.routes.ts
===== ./src/api/routes/transaction.routes.ts =====
import { Router } from "express";
import { requireAuth, requireRoles } from "../middleware/auth.middleware";
import { validateBody } from "../middleware/validateRequest";
import { CreateTransactionSchema } from "../validators/transaction.validation";
import { TransactionController } from "../controllers/transaction.controller";
import { TransactionsService } from "../../application/services/transactions.service";
import { AccountRepo } from "../../repositories/account.repo";
import { TransactionRepo } from "../../repositories/transaction.repo";
import { buildNotificationCenter } from "../../application/notifications/notification.wiring";
import { z } from "zod";

const router = Router();

const service = new TransactionsService(new AccountRepo(), new TransactionRepo(), buildNotificationCenter());
const controller = new TransactionController(service);

router.post("/", requireAuth, validateBody(CreateTransactionSchema), controller.create);

// approvals
router.get("/pending", requireAuth, requireRoles("ADMIN", "TELLER", "MANAGER"), controller.pending);
router.patch("/:id/approve", requireAuth, requireRoles("ADMIN", "TELLER", "MANAGER"), controller.approve);
router.patch("/:id/reject", requireAuth, requireRoles("ADMIN", "TELLER", "MANAGER"), validateBody(z.object({ reason: z.string().optional() })), controller.reject);

export default router;

./src/api/validators/account.features.validation.ts
===== ./src/api/validators/account.features.validation.ts =====
import { z } from "zod";

export const AddFeatureSchema = z.object({
  type: z.enum(["PREMIUM", "INSURANCE", "OVERDRAFT_PLUS"]),
  numberValue: z.coerce.number().nonnegative().optional(),
});

./src/api/validators/account.validation.ts
===== ./src/api/validators/account.validation.ts =====
import { z } from 'zod';
import { AccountType } from '@prisma/client';
import { AccountStateAction } from '../../domain/accounts/state';

export const CreateAccountSchema = z.object({
  userId: z.coerce.number().int().positive(),
  accountType: z.nativeEnum(AccountType),
  name: z.string().trim().min(3).max(30),
  initialBalance: z.coerce.number().nonnegative().optional(),
  parentAccountId: z.coerce.number().int().positive().optional(),
});

export const ChangeStateSchema = z.object({
  action: z.nativeEnum(AccountStateAction),
});
export const RenameAccountSchema = z.object({
  newName: z.string().trim().min(3).max(30),
});
export const CreateAccountGroupSchema = z.object({
  name: z.string().trim().min(3).max(30),
  childAccountIds: z.array(z.coerce.number().int().positive()),
});

./src/api/validators/auth.validators.ts
===== ./src/api/validators/auth.validators.ts =====
import { z } from 'zod';

export const RegisterSchema = z.object({
  username: z.string().trim().min(3).max(30),
  password: z.string().min(6).max(100),
  email: z.string().email(),
  phone: z.string().trim().min(6).max(30).optional(),
});

export const CreateStaffSchema = z.object({
  username: z.string().trim().min(3).max(30),
  password: z.string().min(6).max(100),
  email: z.string().email(),
  phone: z.string().trim().min(6).max(30).optional(),
  role: z.enum(['MANAGER', 'TELLER', 'CUSTOMER']),
});

export const ResendCodeSchema = z.object({
  email: z.string().email(),
});

export const VerifyEmailSchema = z.object({
  email: z.string().email(),
  code: z.string().trim().length(6),
});

export const LoginSchema = z.object({
  username: z.string().trim().min(3).max(30),
  password: z.string().min(6).max(100),
});

export const RefreshSchema = z.object({
  refreshToken: z.string().min(10),
});

./src/api/validators/scheduledTransaction.validation.ts
===== ./src/api/validators/scheduledTransaction.validation.ts =====
import { z } from "zod";

export const CreateScheduledTxSchema = z.object({
  type: z.enum(["DEPOSIT", "WITHDRAWAL", "TRANSFER"]),
  amount: z.coerce.number().positive(),
  fromAccountId: z.coerce.number().int().positive().optional(),
  toAccountId: z.coerce.number().int().positive().optional(),
  frequency: z.enum(["DAILY", "WEEKLY", "MONTHLY"]),
  nextRunAt: z.string().min(10), // ISO string
});

./src/api/validators/ticket.validation.ts
===== ./src/api/validators/ticket.validation.ts =====
import { z } from "zod";

export const CreateTicketSchema = z.object({
  subject: z.string().trim().min(3).max(100),
  description: z.string().trim().min(3).max(2000),
});

export const UpdateTicketStatusSchema = z.object({
  status: z.enum(["OPEN", "IN_PROGRESS", "CLOSED"]),
});

./src/api/validators/transaction.validation.ts
===== ./src/api/validators/transaction.validation.ts =====
import { z } from "zod";

export const CreateTransactionSchema = z.object({
  type: z.enum(["DEPOSIT", "WITHDRAWAL", "TRANSFER"]),
  amount: z.coerce.number().positive(),
  fromAccountId: z.coerce.number().int().positive().optional(),
  toAccountId: z.coerce.number().int().positive().optional(),
});

./src/app.ts
===== ./src/app.ts =====
import express from 'express';
import dotenv from 'dotenv';
import helmet from 'helmet';
import cors from 'cors';
import morgan from 'morgan';
import routes from './api/routes';
import { errorHandler } from './api/middleware/errorHandler';
import { getLandingPage } from './landingpage';

dotenv.config();

const app = express();

app.use(helmet());
app.use(cors());
app.use(morgan('dev'));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.get('/',getLandingPage );

app.use('/api', routes);

app.use(errorHandler);

export default app;

./src/application/errors/http-error.ts
===== ./src/application/errors/http-error.ts =====
export class HttpError extends Error {
  constructor(
    public status: number,
    message: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'HttpError';
  }
}

./src/application/mappers/account.mapper.ts
===== ./src/application/mappers/account.mapper.ts =====
import { Account as DbAccount, AccountState as DbState } from '@prisma/client';
import { AccountFactory } from '../../domain/accounts/AccountFactory';
import { AccountComponent } from '../../domain/accounts/composite/AccountComponent';
import { AccountGroup } from '../../domain/accounts/composite/AccountGroup';
import { AccountLeaf } from '../../domain/accounts/composite/AccountLeaf';

// استيراد الـ States
import { ActiveState } from '../../domain/accounts/state/ActiveState';
import { FrozenState } from '../../domain/accounts/state/FrozenState';
import { SuspendedState } from '../../domain/accounts/state/SuspendedState';
import { ClosedState } from '../../domain/accounts/state/ClosedState';

type DbAccountWithChildren = DbAccount & { subAccounts?: DbAccount[] };

export class AccountMapper {
  static toDomain(db: DbAccountWithChildren): AccountComponent {
  if (db.accountType === 'GROUP') {
  const group = new AccountGroup(db.id.toString(), `Group#${db.id}`);

  (db.subAccounts ?? []).forEach(child => {
    group.add(this.toDomain(child));
  });

  return group;
}

    // 2. إذا لم يكن لديه -> Leaf
    const leaf = AccountFactory.create({
      id: db.id.toString(),
      name: db.name,
      type: db.accountType,
      initialBalance: Number(db.balance),
      state:db.state === 'ACTIVE' ? new ActiveState() :
            db.state === 'FROZEN' ? new FrozenState() :
            db.state === 'SUSPENDED' ? new SuspendedState() :
            new ClosedState(),
    }) as AccountLeaf;

   
    return leaf;
  }

 
  static balanceToDbDecimal(balance: number) {
    const { Prisma } = require('@prisma/client');
    return new Prisma.Decimal(balance);
  }
}
./src/application/notifications/notification-center.ts
===== ./src/application/notifications/notification-center.ts =====
import { Subject } from '../../domain/notifications/subject';
import { AccountEvent } from '../../domain/notifications/events';

export class NotificationCenter extends Subject<AccountEvent> {}

./src/application/notifications/notification.wiring.ts
===== ./src/application/notifications/notification.wiring.ts =====
import { NotificationCenter } from './notification-center';
import { EmailNotificationObserver } from './observers/email.observer';
import { SmsNotificationObserver } from './observers/sms.observer';
import { InAppNotificationObserver } from './observers/inapp.observer';

export function buildNotificationCenter() {
  const center = new NotificationCenter();

  center.subscribe(new InAppNotificationObserver());
  center.subscribe(new EmailNotificationObserver());
  center.subscribe(new SmsNotificationObserver());

  return center;
}

./src/application/notifications/observers/email.observer.ts
===== ./src/application/notifications/observers/email.observer.ts =====
import prisma from '../../../infrastructure/prisma/client';
import { mailer } from '../../../infrastructure/mailer/mailer';
import { Observer } from '../../../domain/notifications/observer';
import { AccountEvent } from '../../../domain/notifications/events';
import { NotificationRepo } from '../../../repositories/notification.repo';
import { UserRepo } from '../../../repositories/user.repo';

export class EmailNotificationObserver implements Observer<AccountEvent> {
 notifRepo = new NotificationRepo();
    userRepo = new UserRepo();

async update(event: AccountEvent) {
 

    const user = await this.userRepo.findById(event.userId);

    if (!user?.email) return;

    await mailer.sendMail({
      from: process.env.SMTP_USER,
      to: user.email,
      subject: 'Account notification',
      text: event.message ,
    });

   await this.notifRepo.create({
      userId: event.userId,
      relatedAccountId: event.accountId,
      channel: 'EMAIL',
      message: event.message ,
      status: 'SENT',
    });
  }
}

./src/application/notifications/observers/inapp.observer.ts
===== ./src/application/notifications/observers/inapp.observer.ts =====
import prisma from '../../../infrastructure/prisma/client';
import { Observer } from '../../../domain/notifications/observer';
import { AccountEvent } from '../../../domain/notifications/events';
import { NotificationRepo } from '../../../repositories/notification.repo';

export class InAppNotificationObserver implements Observer<AccountEvent> {
    notfiRepo = new NotificationRepo();
  async update(event: AccountEvent) {
    await this.notfiRepo.create({
      userId: event.userId,

      relatedAccountId: event.accountId,
      channel: 'IN_APP',
      message: event.message ,
      status: 'SENT',
    });
}}

./src/application/notifications/observers/sms.observer.ts
===== ./src/application/notifications/observers/sms.observer.ts =====
import prisma from '../../../infrastructure/prisma/client';
import { Observer } from '../../../domain/notifications/observer';
import { AccountEvent } from '../../../domain/notifications/events';
import { NotificationRepo } from '../../../repositories/notification.repo';
import { UserRepo } from '../../../repositories/user.repo';

export class SmsNotificationObserver implements Observer<AccountEvent> {
notifRepo = new NotificationRepo();
userRepo = new UserRepo();
    async update(event: AccountEvent) {

   const user = await this.userRepo.findById(event.userId);
    if (!user?.phone) return;
//sent here

    const rec = await this.notifRepo.create({
      userId: event.userId,
      relatedAccountId: event.accountId,
      channel: 'SMS',
      message: event.message,
      status: 'PENDING',
    });
  }
}

./src/application/services/accounts.service.ts
===== ./src/application/services/accounts.service.ts =====
import { AccountRepo } from '../../repositories/account.repo';
import { AccountMapper } from '../mappers/account.mapper';
import { HttpError } from '../errors/http-error';
import { AccountType } from '@prisma/client';
import { AccountStateAction } from '../../domain/accounts/state';
import { AccountLeaf } from '../../domain/accounts/composite/AccountLeaf';
import { AccountGroup } from '../../domain/accounts/composite/AccountGroup';
import { NotificationCenter } from '../notifications/notification-center';
import { AccountEvent } from '../../domain/notifications/events';

import prisma from '../../infrastructure/prisma/client';
import { unwrapToBase } from '../../domain/accounts/decorator/unwrap';

export class AccountsService {
  constructor(
    private readonly repo: AccountRepo,
    private readonly notifications: NotificationCenter
  ) {}

  async createAccount(params: {
    userId: number;
    accountType: AccountType;
    initialBalance?: number;
    parentAccountId?: number;
    name: string;
  }) {
    if (params.parentAccountId) {
      const parent = await this.repo.findById(params.parentAccountId);
      if (!parent) throw new HttpError(404, 'Parent account not found');
    }

    const created = await this.repo.create({
      user: { connect: { id: params.userId } },
      accountType: params.accountType,
      name: params.name,
      balance: AccountMapper.balanceToDbDecimal(params.initialBalance ?? 0),
      parentAccount: params.parentAccountId
        ? { connect: { id: params.parentAccountId } }
        : undefined,
    });

    const event: AccountEvent = {
      type: 'ACCOUNT_CREATED',
      at: new Date(),
      userId: params.userId,
      message: `Account ${created.getName()} has been created`,
      accountId: Number(created.getId()),
      accountName: created.getName(),
    };
    await this.notifications.notify(event);

    return created;
  }

  async getAccount(id: number) {
    const acc = await this.repo.findByIdDecorated(id);
    if (!acc) throw new HttpError(404, 'Account not found');
    return acc;
  }

  async listUserAccounts(userId: number) {
    return this.repo.findManyByUserId(userId);
  }

  async listAccountsApi(requester: { userId: number; role: string }, userIdParam?: number) {
    const staff = ["ADMIN", "TELLER", "MANAGER"].includes(requester.role);
    const target = staff && userIdParam ? userIdParam : requester.userId;
    return this.listUserAccounts(target);
  }

  async renameAccountApi(requester: { userId: number; role: string }, accountId: number, newName: string) {
    const acc = await prisma.account.findUnique({ where: { id: accountId }, select: { id: true, userId: true, accountType: true } });
    if (!acc) throw new HttpError(404, "Account not found");

    const staff = ["ADMIN", "TELLER", "MANAGER"].includes(requester.role);
    if (!staff && acc.userId !== requester.userId) throw new HttpError(403, "Forbidden");

    await prisma.account.update({ where: { id: accountId }, data: { name: newName } });
    return { ok: true };
  }

  async changeState(id: number, action: AccountStateAction) {
    const account = await this.repo.findByIdDecorated(id);
    if (!account) throw new HttpError(404, 'Account not found');

    const raw: any = unwrapToBase(account as any);

    if (!(raw instanceof AccountLeaf)) {
      throw new HttpError(400, 'Cannot change state of an account group directly');
    }

    this.applyAction(raw, action);
    await this.repo.save(account);

    const owner = await this.repo.getOwnerUserIdByAccountId(id);

    const event: AccountEvent = {
      type: 'ACCOUNT_STATE_CHANGED',
      at: new Date(),
      userId: owner,
      accountId: id,
      accountName: raw.getName(),
      message: `Account ${raw.getName()} has been ${action}`,
    };
    await this.notifications.notify(event);

    return raw;
  }

  private applyAction(acc: AccountLeaf, action: AccountStateAction) {
    const actions: Record<string, () => void> = {
      [AccountStateAction.FREEZE]: () => acc.freeze(),
      [AccountStateAction.SUSPEND]: () => acc.suspend(),
      [AccountStateAction.ACTIVATE]: () => acc.activate(),
      [AccountStateAction.CLOSE]: () => acc.close(),
    };

    if (!actions[action]) throw new HttpError(400, 'Invalid action');
    actions[action]!();
  }

  async createAccountGroup(params: { userId: number; name: string; childAccountIds: number[] }) {
    const accounts = await Promise.all(params.childAccountIds.map(id => this.repo.findById(id)));
    if (accounts.some(acc => !acc)) throw new HttpError(404, 'One or more accounts not found');

    const group = await this.repo.createGroup({ userId: params.userId, name: params.name });

    await Promise.all(params.childAccountIds.map(childId => this.repo.setParent(childId, Number(group.getId()))));
    return group;
  }

  async addToGroup(groupId: number, childAccountId: number) {
    const group = await this.repo.findById(groupId);
    const child = await this.repo.findById(childAccountId);

    if (!group || !child) throw new HttpError(404, 'Account not found');
    if (!(group instanceof AccountGroup)) throw new HttpError(400, 'Target is not a group account');

    await this.repo.setParent(childAccountId, groupId);
    return { message: 'Account added to group successfully' };
  }

  async removeFromGroup(groupId: number, childAccountId: number) {
    const group = await this.repo.findById(groupId);
    const child = await this.repo.findById(childAccountId);

    if (!group || !child) throw new HttpError(404, 'Account not found');
    if (!(group instanceof AccountGroup)) throw new HttpError(400, 'Target is not a group account');

    await this.repo.removeParent(childAccountId);
    return { message: 'Account removed from group successfully' };
  }

  async addFeature(accountId: number, input: { type: 'PREMIUM'|'INSURANCE'|'OVERDRAFT_PLUS'; numberValue?: number }) {
    const acc = await prisma.account.findUnique({ where: { id: accountId } });
    if (!acc) throw new HttpError(404, 'Account not found');

    if (input.type === 'OVERDRAFT_PLUS' && acc.accountType !== 'CHECKING') {
      throw new HttpError(400, 'OVERDRAFT_PLUS only allowed for CHECKING accounts');
    }

    await this.repo.addFeature(accountId, input.type, input.numberValue);
    return { ok: true };
  }

  async removeFeature(accountId: number, type: 'PREMIUM'|'INSURANCE'|'OVERDRAFT_PLUS') {
    await this.repo.removeFeature(accountId, type);
    return { ok: true };
  }

  async searchAccounts(filters: {
    userId?: number;
    accountType?: AccountType;
    state?: string;
    minBalance?: number;
    maxBalance?: number;
  }) {
    return this.repo.search(filters);
  }
}

./src/application/services/admin.service.ts
===== ./src/application/services/admin.service.ts =====
import { AdminRepo } from "../../repositories/admin.repo";
import { HttpError } from "../errors/http-error";

function parseDateYYYYMMDD(s?: string) {
  if (!s) return null;
  const ok = /^\\d{4}-\\d{2}-\\d{2}$/.test(s);
  if (!ok) throw new HttpError(400, "Invalid date format. Use YYYY-MM-DD");
  const d = new Date(s + "T00:00:00.000Z");
  if (Number.isNaN(d.getTime())) throw new HttpError(400, "Invalid date");
  return d;
}

export class AdminService {
  constructor(private readonly repo = new AdminRepo()) {}

  dashboard() {
    return this.repo.dashboard();
  }

  dailyTx(dateStr?: string) {
    const d = parseDateYYYYMMDD(dateStr) ?? new Date();
    return this.repo.dailyTransactionsReport(d);
  }

  accountsSummary(filters: { userId?: number; type?: string; state?: string }) {
    return this.repo.accountsSummaryReport(filters);
  }

  audit(filters: { from?: string; to?: string; userId?: number; eventType?: string }) {
    const from = parseDateYYYYMMDD(filters.from) ?? undefined;
    const to = parseDateYYYYMMDD(filters.to) ?? undefined;
    return this.repo.auditReport({ from, to, userId: filters.userId, eventType: filters.eventType });
  }
}

./src/application/services/auth.service.ts
===== ./src/application/services/auth.service.ts =====
import bcrypt from 'bcrypt';
import { HttpError } from '../errors/http-error';
import { UserRepo } from '../../repositories/user.repo';
import { RefreshTokenRepo } from '../../repositories/refreshToken.repo';
import { EmailVerificationRepo } from '../../repositories/emailVerification.repo';
import { mailer } from '../../infrastructure/mailer/mailer';
import { sha256 } from '../../infrastructure/auth/hash';
import { signAccessToken, signRefreshToken, verifyToken } from '../../infrastructure/auth/jwt';
import { Role } from '@prisma/client';

function random6Digits() {
  return String(Math.floor(100000 + Math.random() * 900000));
}

export class AuthService {
  constructor(
    private readonly users = new UserRepo(),
    private readonly refreshRepo = new RefreshTokenRepo(),
    private readonly emailRepo = new EmailVerificationRepo()
  ) {}
 async createStaff(input: { username: string; password: string; email: string; phone?: string , role: Role}) {
    const byUsername = await this.users.findByUsername(input.username);
    if (byUsername) throw new HttpError(409, 'Username already exists');

    const byEmail = await this.users.findByEmail(input.email);
    if (byEmail) {
      if (byEmail.isEmailVerified) throw new HttpError(409, 'Email already registered');
    
    }

    const passwordHash = await bcrypt.hash(input.password, 10);

    await this.users.create({
      username: input.username,
      passwordHash,
      email: input.email,
      phone: input.phone,
      role: input.role,
      isEmailVerified: true,
    });


    return { ok: true, message: 'Registered.' };
  }

  // ✅ Register: creates user NOT verified + sends code
  // ✅ If email exists & NOT verified => just resend code (no new user)
  async register(input: { username: string; password: string; email: string; phone?: string }) {
    const byUsername = await this.users.findByUsername(input.username);
    if (byUsername) throw new HttpError(409, 'Username already exists');

    const byEmail = await this.users.findByEmail(input.email);
    if (byEmail) {
      if (byEmail.isEmailVerified) throw new HttpError(409, 'Email already registered');
      // existing but not verified => resend code
      await this.sendVerificationCode(input.email);
      return { ok: true, message: 'Account exists but not verified. Code resent.' };
    }

    const passwordHash = await bcrypt.hash(input.password, 10);

    await this.users.create({
      username: input.username,
      passwordHash,
      email: input.email,
      phone: input.phone,
      role: 'CUSTOMER',
      isEmailVerified: false,
    });

    await this.sendVerificationCode(input.email);

    return { ok: true, message: 'Registered. Verification code sent to email.' };
  }

  // ✅ Resend code (only if user exists and NOT verified)
  async resendCode(email: string) {
    const user = await this.users.findByEmail(email);
    if (!user) throw new HttpError(404, 'User not found');
    if (user.isEmailVerified) return { ok: true, message: 'Already verified' };

    await this.sendVerificationCode(email);
    return { ok: true, message: 'Verification code resent' };
  }

  // ✅ Verify email => activates account + returns tokens
  async verifyEmail(input: { email: string; code: string }) {
    const user = await this.users.findByEmail(input.email);
    if (!user) throw new HttpError(404, 'User not found');

    if (user.isEmailVerified) {
      // optional: still issue tokens if already verified
      const tokens = await this.issueTokens(user.id, user.role);
      return { ok: true, message: 'Already verified', ...tokens };
    }

    const record = await this.emailRepo.findValid(input.email, sha256(input.code));
    if (!record) throw new HttpError(400, 'Invalid or expired code');

    await this.emailRepo.markUsed(record.id);
    const updated = await this.users.setEmailVerified(user.id);

    const tokens = await this.issueTokens(updated.id, updated.role);
    return { ok: true, message: 'Email verified', ...tokens };
  }

  async login(input: { username: string; password: string }) {
    const user = await this.users.findByUsername(input.username);
    if (!user) throw new HttpError(401, 'Invalid credentials');

    if (!user.isEmailVerified) throw new HttpError(403, 'Email not verified');

    const ok = await bcrypt.compare(input.password, user.passwordHash);
    if (!ok) throw new HttpError(401, 'Invalid credentials');

    const tokens = await this.issueTokens(user.id, user.role);
    return { user: this.safeUser(user), ...tokens };
  }

  // refresh rotation
  async refresh(refreshToken: string) {
    const payload = verifyToken(refreshToken);
    const tokenHash = sha256(refreshToken);

    const found = await this.refreshRepo.findValid(tokenHash);
    if (!found) throw new HttpError(401, 'Refresh token invalid, revoked, or expired');

    await this.refreshRepo.revokeByHash(tokenHash);

    const tokens = await this.issueTokens(payload.userId, found.user.role);
    return tokens;
  }

  async logout(refreshToken: string) {
    await this.refreshRepo.revokeByHash(sha256(refreshToken));
    return { ok: true };
  }

  async me(userId: number) {
    const user = await this.users.findById(userId);
    if (!user) throw new HttpError(404, 'User not found');
    return this.safeUser(user);
  }

  // ---------- helpers ----------
  private async sendVerificationCode(email: string) {
    const code = random6Digits();
    const codeHash = sha256(code);
    const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

    await this.emailRepo.create(email, codeHash, expiresAt);

    await mailer.sendMail({
      from: process.env.SMTP_USER,
      to: email,
      subject: 'Verify your email',
      text: `Your verification code is: ${code} (expires in 10 minutes)`,
    });
  }

  private async issueTokens(userId: number, role: string) {
    const payload = { userId, role };
    const accessToken = signAccessToken(payload);
    const refreshToken = signRefreshToken(payload);

    // approximate expiry (match env 30d)
    const expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
    await this.refreshRepo.create(userId, sha256(refreshToken), expiresAt);

    return { accessToken, refreshToken };
  }

  private safeUser(u: any) {
    const { passwordHash, ...rest } = u;
    return rest;
  }
}

./src/application/services/events.service.ts
===== ./src/application/services/events.service.ts =====
import { EventRepo } from "../../repositories/event.repo";

export class EventsService {
  constructor(private readonly repo = new EventRepo()) {}

  list(requester: { userId: number; role: string }, filters?: { userId?: number }) {
    const staff = ["ADMIN", "TELLER", "MANAGER"].includes(requester.role);
    if (staff) return this.repo.listAll(filters);
    return this.repo.listForUser(requester.userId);
  }
}

./src/application/services/notifications.service.ts
===== ./src/application/services/notifications.service.ts =====
import { NotificationRepo } from "../../repositories/notification.repo";

export class NotificationsService {
  constructor(private readonly repo = new NotificationRepo()) {}

  list(userId: number) {
    return this.repo.listByUser(userId);
  }

  async markRead(userId: number, id: number) {
    await this.repo.markRead(userId, id);
    return { ok: true };
  }
}

./src/application/services/scheduledTransactions.service.ts
===== ./src/application/services/scheduledTransactions.service.ts =====
import { Frequency, TransactionType } from "@prisma/client";
import { HttpError } from "../errors/http-error";
import { ScheduledTransactionRepo } from "../../repositories/scheduledTransaction.repo";
import prisma from "../../infrastructure/prisma/client";

function nextDate(freq: Frequency, from: Date) {
  const d = new Date(from);
  if (freq === "DAILY") d.setDate(d.getDate() + 1);
  if (freq === "WEEKLY") d.setDate(d.getDate() + 7);
  if (freq === "MONTHLY") d.setMonth(d.getMonth() + 1);
  return d;
}

export class ScheduledTransactionsService {
  constructor(private readonly repo = new ScheduledTransactionRepo()) {}

  async create(requester: { userId: number }, input: {
    type: TransactionType;
    amount: number;
    fromAccountId?: number;
    toAccountId?: number;
    frequency: Frequency;
    nextRunAt: string;
  }) {
    if (input.amount <= 0) throw new HttpError(400, "Amount must be positive");

    if (input.type === "DEPOSIT" && !input.toAccountId) throw new HttpError(400, "toAccountId required");
    if (input.type === "WITHDRAWAL" && !input.fromAccountId) throw new HttpError(400, "fromAccountId required");
    if (input.type === "TRANSFER" && (!input.fromAccountId || !input.toAccountId))
      throw new HttpError(400, "fromAccountId and toAccountId required");

    // Ownership checks for customers (optional but important)
    const toCheck = [input.fromAccountId, input.toAccountId].filter(Boolean) as number[];
    const accounts = await prisma.account.findMany({ where: { id: { in: toCheck } }, select: { id: true, userId: true } });
    for (const a of accounts) {
      if (a.userId !== requester.userId) throw new HttpError(403, "You can only schedule for your own accounts");
    }

    const nextRun = new Date(input.nextRunAt);
    if (Number.isNaN(nextRun.getTime())) throw new HttpError(400, "Invalid nextRunAt");

    return this.repo.create({
      createdById: requester.userId,
      fromAccountId: input.fromAccountId,
      toAccountId: input.toAccountId,
      amount: input.amount,
      type: input.type,
      frequency: input.frequency,
      nextRunAt: nextRun,
    });
  }

  list(requester: { userId: number }) {
    return this.repo.listByUser(requester.userId);
  }

  async stop(requester: { userId: number }, id: number) {
    await this.repo.stop(requester.userId, id);
    return { ok: true };
  }

  async resume(requester: { userId: number }, id: number) {
    await this.repo.resume(requester.userId, id);
    return { ok: true };
  }

  // helper for runner
  computeNextRun(freq: Frequency, from: Date) {
    return nextDate(freq, from);
  }
}

./src/application/services/tickets.service.ts
===== ./src/application/services/tickets.service.ts =====
import { TicketStatus } from "@prisma/client";
import { HttpError } from "../errors/http-error";
import { TicketRepo } from "../../repositories/ticket.repo";

export class TicketsService {
  constructor(private readonly repo = new TicketRepo()) {}

  create(userId: number, input: { subject: string; description: string }) {
    return this.repo.create({ userId, ...input });
  }

  list(requester: { userId: number; role: string }) {
    const staff = ["ADMIN", "TELLER", "MANAGER"].includes(requester.role);
    return staff ? this.repo.listAll() : this.repo.listForUser(requester.userId);
  }

  async setStatus(requester: { role: string }, id: number, status: TicketStatus) {
    const staff = ["ADMIN", "TELLER", "MANAGER"].includes(requester.role);
    if (!staff) throw new HttpError(403, "Forbidden");
    return this.repo.updateStatus(id, status);
  }
}

./src/application/services/transactions.service.ts
===== ./src/application/services/transactions.service.ts =====
import { Prisma, TransactionType } from "@prisma/client";
import prisma from "../../infrastructure/prisma/client";
import { HttpError } from "../errors/http-error";
import { AccountRepo } from "../../repositories/account.repo";
import { TransactionRepo } from "../../repositories/transaction.repo";
import { NotificationCenter } from "../notifications/notification-center";

import { AutoApprove } from "../../domain/transactions/approval/AutoApprove";
import { TellerApprove } from "../../domain/transactions/approval/TellerApprove";
import { ManagerApprove } from "../../domain/transactions/approval/ManagerApprove";

export class TransactionsService {
  constructor(
    private readonly accounts: AccountRepo,
    private readonly txRepo: TransactionRepo,
    private readonly notifications: NotificationCenter
  ) {}

  private chain() {
    const c = new AutoApprove(100);
    c.setNext(new TellerApprove(1000)).setNext(new ManagerApprove());
    return c;
  }

  async create(input: {
    type: TransactionType;
    amount: number;
    fromAccountId?: number;
    toAccountId?: number;
    requester: { userId: number; role: string };
  }) {
    if (input.amount <= 0) throw new HttpError(400, "Amount must be positive");

    if (input.type === "DEPOSIT" && !input.toAccountId) throw new HttpError(400, "toAccountId required");
    if (input.type === "WITHDRAWAL" && !input.fromAccountId) throw new HttpError(400, "fromAccountId required");
    if (input.type === "TRANSFER" && (!input.fromAccountId || !input.toAccountId))
      throw new HttpError(400, "fromAccountId and toAccountId required");

    const decision = this.chain().handle({
      type: input.type,
      amount: input.amount,
      requestedByRole: input.requester.role,
    });

    const amountDec = new Prisma.Decimal(input.amount);

    const txRecord = await prisma.transaction.create({
      data: {
        type: input.type,
        amount: amountDec,
        status: decision.approved ? "COMPLETED" : "PENDING",
        fromAccountId: input.fromAccountId,
        toAccountId: input.toAccountId,
        approvedById: decision.approved && decision.level !== "AUTO" ? input.requester.userId : null,
      },
    });

    if (!decision.approved) {
      await prisma.eventLog.create({
        data: {
          userId: input.requester.userId,
          accountId: input.fromAccountId ?? input.toAccountId ?? null,
          transactionId: txRecord.id,
          eventType: "TX_PENDING",
          details: { decision },
        },
      });
      return { tx: txRecord, approval: decision };
    }

    await this.applyBalancesAndLog({
      txId: txRecord.id,
      type: input.type,
      amount: input.amount,
      fromAccountId: input.fromAccountId,
      toAccountId: input.toAccountId,
      approvedById: decision.level !== "AUTO" ? input.requester.userId : null,
      actorUserId: input.requester.userId,
      decision,
    });

    return { tx: { ...txRecord, status: "COMPLETED" }, approval: decision };
  }

  async pending(requester: { role: string }) {
    const staff = ["ADMIN", "TELLER", "MANAGER"].includes(requester.role);
    if (!staff) throw new HttpError(403, "Forbidden");
    return this.txRepo.pending();
  }

  async approve(requester: { userId: number; role: string }, txId: number) {
    const staff = ["ADMIN", "TELLER", "MANAGER"].includes(requester.role);
    if (!staff) throw new HttpError(403, "Forbidden");

    const tx = await prisma.transaction.findUnique({ where: { id: txId } });
    if (!tx) throw new HttpError(404, "Transaction not found");
    if (tx.status !== "PENDING") throw new HttpError(400, "Transaction is not pending");

    // manager/admin can approve any amount; teller should not approve huge ones (optional rule)
    if (requester.role === "TELLER" && Number(tx.amount) > 1000) {
      throw new HttpError(403, "TELLER cannot approve this amount");
    }

    await this.applyBalancesAndLog({
      txId: tx.id,
      type: tx.type,
      amount: Number(tx.amount),
      fromAccountId: tx.fromAccountId ?? undefined,
      toAccountId: tx.toAccountId ?? undefined,
      approvedById: requester.userId,
      actorUserId: requester.userId,
      decision: { approved: true, level: requester.role === "TELLER" ? "TELLER" : "MANAGER" },
    });

    return { ok: true };
  }

  async reject(requester: { userId: number; role: string }, txId: number, reason?: string) {
    const staff = ["ADMIN", "TELLER", "MANAGER"].includes(requester.role);
    if (!staff) throw new HttpError(403, "Forbidden");

    const tx = await prisma.transaction.findUnique({ where: { id: txId } });
    if (!tx) throw new HttpError(404, "Transaction not found");
    if (tx.status !== "PENDING") throw new HttpError(400, "Transaction is not pending");

    await prisma.transaction.update({
      where: { id: txId },
      data: { status: "FAILED", approvedById: requester.userId },
    });

    await prisma.eventLog.create({
      data: {
        userId: requester.userId,
        accountId: tx.fromAccountId ?? tx.toAccountId ?? null,
        transactionId: tx.id,
        eventType: "TX_REJECTED",
        details: { reason: reason ?? "rejected" },
      },
    });

    return { ok: true };
  }

  private async applyBalancesAndLog(args: {
    txId: number;
    type: TransactionType;
    amount: number;
    fromAccountId?: number;
    toAccountId?: number;
    approvedById: number | null;
    actorUserId: number;
    decision: any;
  }) {
    const amount = args.amount;

    let fromNew: Prisma.Decimal | undefined;
    let toNew: Prisma.Decimal | undefined;

    if (args.type === "DEPOSIT") {
      const toAcc = await this.accounts.findByIdDecorated(args.toAccountId!);
      if (!toAcc) throw new HttpError(404, "Account not found");
      toAcc.deposit(amount);
      toNew = new Prisma.Decimal(toAcc.getBalance());
    }

    if (args.type === "WITHDRAWAL") {
      const fromAcc = await this.accounts.findByIdDecorated(args.fromAccountId!);
      if (!fromAcc) throw new HttpError(404, "Account not found");
      fromAcc.withdraw(amount);
      fromNew = new Prisma.Decimal(fromAcc.getBalance());
    }

    if (args.type === "TRANSFER") {
      const fromAcc = await this.accounts.findByIdDecorated(args.fromAccountId!);
      const toAcc = await this.accounts.findByIdDecorated(args.toAccountId!);
      if (!fromAcc || !toAcc) throw new HttpError(404, "Account not found");

      fromAcc.withdraw(amount);
      toAcc.deposit(amount);

      fromNew = new Prisma.Decimal(fromAcc.getBalance());
      toNew = new Prisma.Decimal(toAcc.getBalance());
    }

    await this.txRepo.atomicApplyAndMark({
      txId: args.txId,
      status: "COMPLETED",
      approvedById: args.approvedById,
      fromAccountId: args.fromAccountId,
      toAccountId: args.toAccountId,
      fromNewBalance: fromNew,
      toNewBalance: toNew,
    });

    await prisma.eventLog.create({
      data: {
        userId: args.actorUserId,
        accountId: args.fromAccountId ?? args.toAccountId ?? null,
        transactionId: args.txId,
        eventType: "TX_COMPLETED",
        details: { decision: args.decision },
      },
    });

    await this.notifications.notify({
      type: "ACCOUNT_STATE_CHANGED" as any,
      at: new Date(),
      userId: args.actorUserId,
      accountId: (args.fromAccountId ?? args.toAccountId) as number,
      accountName: undefined,
      message: `Transaction completed: ${args.type} amount=${amount}`,
    } as any);
  }
}

./src/domain/accounts/AccountFactory.ts
===== ./src/domain/accounts/AccountFactory.ts =====
import { AccountType } from './types';
import { AccountLeaf } from './composite/AccountLeaf';
import { SavingsAccount } from './composite/SavingsAccount';
import { CheckingAccount } from './composite/CheckingAccount';
import { LoanAccount } from './composite/LoanAccount';
import { InvestmentAccount } from './composite/InvestmentAccount';
import { AccountState } from '../accounts/state/AccountState';

export class AccountFactory {
  static create(params: {
    id: string;
    name: string;
    type: AccountType;
    initialBalance?: number;
    overdraftLimit?: number; 
    state :AccountState
  }): AccountLeaf {
    const bal = params.initialBalance ?? 0;

    switch (params.type) {
      case 'SAVINGS':
        return new SavingsAccount(params.id, params.name, bal, params.state);
     case 'CHECKING':
  return new CheckingAccount(
    params.id,
    params.name,
    bal,
    params.overdraftLimit ?? 0,
    params.state
  );

      case 'LOAN':
        return new LoanAccount(params.id, params.name, bal, params.state);

      case 'INVESTMENT':
        return new InvestmentAccount(params.id, params.name, bal, params.state);
        
      default:
        throw new Error(`Unsupported account type: ${params.type}`);
    }
  }
}

./src/domain/accounts/composite/AccountComponent.ts
===== ./src/domain/accounts/composite/AccountComponent.ts =====
export interface AccountComponent {
  getId(): string;
  getName(): string;
  getBalance(): number;

  rename(newName: string): void;

  deposit(amount: number): void;
  withdraw(amount: number): void;

  add(child: AccountComponent): void;
  remove(childId: string): void;
  getChildren(): AccountComponent[];
}

./src/domain/accounts/composite/AccountGroup.ts
===== ./src/domain/accounts/composite/AccountGroup.ts =====
import { AccountComponent } from './AccountComponent';

export class AccountGroup implements AccountComponent {
  private id: string;
  private name: string;
  private children: AccountComponent[] = [];

  constructor(id: string, name: string) {
    this.id = id;
    this.name = name;
  }
rename(newName: string): void {
  if (!newName.trim()) throw new Error('Group name cannot be empty');
  this.name = newName;
}

 deposit(): void {
    throw new Error('Cannot deposit directly into an account group');
  }

  withdraw(): void {
    throw new Error('Cannot withdraw directly from an account group');
  }

  getId() { return this.id; }
  getName() { return this.name; }

  add(child: AccountComponent): void {
    this.children.push(child);
  }

  remove(childId: string): void {
    this.children = this.children.filter(c => c.getId() !== childId);
  }

  getChildren(): AccountComponent[] {
    return [...this.children];
  }

  getBalance(): number {
    return this.children.reduce((sum, c) => sum + c.getBalance(), 0);
  }
}

./src/domain/accounts/composite/AccountLeaf.ts
===== ./src/domain/accounts/composite/AccountLeaf.ts =====
// src/domain/accounts/composite/AccountLeaf.ts
import { AccountComponent } from './AccountComponent';
import { AccountState } from '../state/AccountState';
import { ActiveState } from '../state/ActiveState';
import { InterestStrategy, InterestContext } from '../interest_strategy/InterestStrategy';


export abstract class AccountLeaf implements AccountComponent {
  protected id: string;
  protected name: string;
  protected balance: number;
  protected state: AccountState;

  constructor(id: string, name: string, initialBalance = 0, state: AccountState = new ActiveState()) {
    this.id = id;
    this.name = name;
    this.balance = initialBalance;
    this.state = state;
  }
  
 rename(newName: string): void {
  if (!newName.trim()) {
    throw new Error('Account name cannot be empty');
  }
  this.name = newName;
}

  getId() { return this.id; }
  getName() { return this.name; }
  getBalance() { return this.balance; }
  getState() { return this.state.name; }

  freeze() { this.state.freeze(this); }
  suspend() { this.state.suspend(this); }
  activate() { this.state.activate(this); }
  close() { this.state.close(this); }

  deposit(amount: number) {
    if (amount <= 0) throw new Error('Amount must be positive');
    this.state.deposit(this, amount);
  }

  withdraw(amount: number) {
    if (amount <= 0) throw new Error('Amount must be positive');
    this.state.withdraw(this, amount);
  }

  setState(s: AccountState) { this.state = s; }

  increaseBalance(a: number) { this.balance += a; }

  decreaseBalance(a: number) {
    this.assertCanWithdraw(a); 
    this.balance -= a;

  }

  protected abstract assertCanWithdraw(amount: number): void;

  calculateInterest(interestStrategy: InterestStrategy,context?: InterestContext): number {
  if (!interestStrategy) return 0;
  return interestStrategy.calculate(this.balance, context);
  }

  add(): void {
    throw new Error('Leaf account cannot have children');
  }
  remove(): void {
    throw new Error('Leaf account cannot have children');
  }
  getChildren(): AccountComponent[] {
    return [];
  }
}

./src/domain/accounts/composite/CheckingAccount.ts
===== ./src/domain/accounts/composite/CheckingAccount.ts =====
import { AccountState } from '../state/AccountState';
import { ActiveState } from '../state/ActiveState';
import { AccountLeaf } from './AccountLeaf';

export class CheckingAccount extends AccountLeaf {
  private overdraftLimit: number;

  constructor(id: string, name: string, initialBalance = 0, overdraftLimit = 0, state: AccountState = new ActiveState()) {
    super(id, name, initialBalance, state);
    this.overdraftLimit = overdraftLimit;
  }

  setOverdraftLimit(limit: number) {
    if (limit < 0) throw new Error('Overdraft limit must be >= 0');
    this.overdraftLimit = limit;
  }

  getOverdraftLimit() {
    return this.overdraftLimit;
  }

  protected assertCanWithdraw(amount: number): void {
    if (this.balance - amount < -this.overdraftLimit) {
      throw new Error('Overdraft limit exceeded (checking)');
    }
  }
}

./src/domain/accounts/composite/InvestmentAccount.ts
===== ./src/domain/accounts/composite/InvestmentAccount.ts =====
import { AccountLeaf } from './AccountLeaf';

export class InvestmentAccount extends AccountLeaf {
  protected assertCanWithdraw(amount: number): void {
    if (amount > this.balance) {
      throw new Error('Insufficient funds (investment)');
    }
  }
}

./src/domain/accounts/composite/LoanAccount.ts
===== ./src/domain/accounts/composite/LoanAccount.ts =====
import { AccountLeaf } from './AccountLeaf';

export class LoanAccount extends AccountLeaf {
  protected assertCanWithdraw(amount: number): void {
    throw new Error('Withdrawals are not allowed from a loan account');
  }
  deposit(amount: number) {
    super.deposit(amount);
  }
}

./src/domain/accounts/composite/SavingsAccount.ts
===== ./src/domain/accounts/composite/SavingsAccount.ts =====
import { AccountLeaf } from './AccountLeaf';

export class SavingsAccount extends AccountLeaf {
  protected assertCanWithdraw(amount: number): void {
    if (amount > this.balance) {
      throw new Error('Insufficient funds (savings)');
    }
  }
}

./src/domain/accounts/decorator/AccountDecorator.ts
===== ./src/domain/accounts/decorator/AccountDecorator.ts =====
import { AccountComponent } from "../composite/AccountComponent";


export abstract class AccountDecorator implements AccountComponent {
  constructor(protected wrap: AccountComponent) {}
  rename(newName: string): void {
    return this.wrap.rename(newName);
  }

  getId() { return this.wrap.getId(); }
  getName() { return this.wrap.getName(); }
  getBalance() { return this.wrap.getBalance(); }

 deposit(amount: number): void { this.wrap.deposit(amount); }
withdraw(amount: number): void { this.wrap.withdraw(amount); }


  add(child: AccountComponent) { return this.wrap.add(child); }
  remove(childId: string) { return this.wrap.remove(childId); }
  getChildren() { return this.wrap.getChildren(); }
}

./src/domain/accounts/decorator/applyDecorators.ts
===== ./src/domain/accounts/decorator/applyDecorators.ts =====
import { AccountComponent } from "../composite/AccountComponent";
import { CheckingAccount } from "../composite/CheckingAccount";
import { InsuranceDecorator } from "./InsuranceDecorator";
import { PremiumServiceDecorator } from "./PremiumServiceDecorator";
import { OverdraftDecorator } from "./OverdraftDecorator";
import { unwrapToBase } from "./unwrap";

export type FeatureRow = {
  type: "PREMIUM" | "INSURANCE" | "OVERDRAFT_PLUS";
  numberValue?: number | null;
};

export function applyDecorators(base: AccountComponent, features: FeatureRow[]): AccountComponent {
  let acc: AccountComponent = base;
  const overdraft = features.find(f => f.type === "OVERDRAFT_PLUS");
  if (overdraft) {
    const raw = unwrapToBase(base);
    if (raw instanceof CheckingAccount) {
      const extra = overdraft.numberValue ?? 100;
      acc = new OverdraftDecorator(raw, extra);
    }
  }

  for (const f of features) {
    if (f.type === "PREMIUM") {
      acc = new PremiumServiceDecorator(acc as any, 0.005);
    }
    if (f.type === "INSURANCE") {
      const fee = f.numberValue ?? 2;
      acc = new InsuranceDecorator(acc as any, fee);
    }
  }

  return acc;
}

./src/domain/accounts/decorator/InsuranceDecorator.ts
===== ./src/domain/accounts/decorator/InsuranceDecorator.ts =====
// src/domain/accounts/decorator/InsuranceDecorator.ts

import { AccountDecorator } from "./AccountDecorator";

export class InsuranceDecorator extends AccountDecorator {
  constructor(wrap: any, private feePerWithdraw = 2) {
    super(wrap);
  }

  withdraw(amount: number) {
    // نسحب المبلغ
    super.withdraw(amount);

    // وبعدين نسحب رسوم التأمين
    super.withdraw(this.feePerWithdraw);
  }
}

./src/domain/accounts/decorator/OverdraftDecorator.ts
===== ./src/domain/accounts/decorator/OverdraftDecorator.ts =====
// src/domain/accounts/decorator/OverdraftDecorator.ts
import { AccountDecorator } from './AccountDecorator';
import { CheckingAccount } from '../composite/CheckingAccount';

export class OverdraftDecorator extends AccountDecorator {
  constructor(wrap: CheckingAccount, extraLimit: number) {
    super(wrap);

    if (extraLimit <= 0) throw new Error('extraLimit must be positive');

    wrap.setOverdraftLimit(wrap.getOverdraftLimit() + extraLimit);
  }
}

./src/domain/accounts/decorator/PremiumServiceDecorator.ts
===== ./src/domain/accounts/decorator/PremiumServiceDecorator.ts =====
import { AccountDecorator } from './AccountDecorator';

export class PremiumServiceDecorator extends AccountDecorator {
  constructor(wrap: any, private cashbackRate = 0.005) {
    super(wrap);
  }

  deposit(amount: number) {
    const cashback = amount * this.cashbackRate;
    return super.deposit(amount + cashback);
  }
}

./src/domain/accounts/decorator/unwrap.ts
===== ./src/domain/accounts/decorator/unwrap.ts =====
import { AccountComponent } from "../composite/AccountComponent";

export function unwrapToBase(acc: AccountComponent): any {
  let cur: any = acc;
  while (cur && typeof cur === "object" && "wrap" in cur) cur = cur.wrap;
  return cur;
}

./src/domain/accounts/interest_strategy/FixedRateInterest.ts
===== ./src/domain/accounts/interest_strategy/FixedRateInterest.ts =====
import { InterestStrategy, InterestContext } from './InterestStrategy';

export class FixedRateInterest implements InterestStrategy {
  constructor(private annualRate: number) {}

  calculate(balance: number, context?: InterestContext): number {
    return Math.max(balance, 0) * this.annualRate;
  }
}

./src/domain/accounts/interest_strategy/InterestStrategy.ts
===== ./src/domain/accounts/interest_strategy/InterestStrategy.ts =====
export interface InterestStrategy {
  calculate(balance: number, context?: InterestContext): number;
}

export interface InterestContext {
  marketRate?: number;  // فائدة السوق
  isPremium?: boolean;  // عميل مميز
}

./src/domain/accounts/interest_strategy/MarketBasedInterest.ts
===== ./src/domain/accounts/interest_strategy/MarketBasedInterest.ts =====
import { InterestStrategy, InterestContext } from './InterestStrategy';

export class MarketBasedInterest implements InterestStrategy {
  constructor(private baseRate: number, private premiumBonus = 0.01) {}

  calculate(balance: number, context?: InterestContext): number {
    const b = Math.max(balance, 0);
    const market = context?.marketRate ?? 0;
    const premium = context?.isPremium ? this.premiumBonus : 0;
    return b * (this.baseRate + market + premium);
  }
}

./src/domain/accounts/interest_strategy/TieredInterest.ts
===== ./src/domain/accounts/interest_strategy/TieredInterest.ts =====
import { InterestStrategy, InterestContext } from './InterestStrategy';

export class TieredInterest implements InterestStrategy {
  constructor(
    private tier1Limit: number,
    private tier1Rate: number,
    private tier2Rate: number
  ) {}

  calculate(balance: number, context?: InterestContext): number {
    const b = Math.max(balance, 0);
    const tier1 = Math.min(b, this.tier1Limit);
    const tier2 = Math.max(b - this.tier1Limit, 0);
    return tier1 * this.tier1Rate + tier2 * this.tier2Rate;
  }
}

./src/domain/accounts/state/AccountState.ts
===== ./src/domain/accounts/state/AccountState.ts =====
import type { AccountLeaf } from '../composite/AccountLeaf';

export interface AccountState {
  name: 'ACTIVE' | 'FROZEN' | 'SUSPENDED' | 'CLOSED';

  deposit(account: AccountLeaf, amount: number): void;
  withdraw(account: AccountLeaf, amount: number): void;

  freeze(account: AccountLeaf): void;
  suspend(account: AccountLeaf): void;
  activate(account: AccountLeaf): void;
  close(account: AccountLeaf): void;
}

./src/domain/accounts/state/ActiveState.ts
===== ./src/domain/accounts/state/ActiveState.ts =====
import type { AccountLeaf } from '../composite/AccountLeaf';
import { AccountState } from './AccountState';
import { FrozenState } from './FrozenState';
import { SuspendedState } from './SuspendedState';
import { ClosedState } from './ClosedState';

export class ActiveState implements AccountState {
  name = 'ACTIVE' as const;

  deposit(account: AccountLeaf, amount: number): void {
    account.increaseBalance(amount);
  }

  withdraw(account: AccountLeaf, amount: number): void {
    account.decreaseBalance(amount); 
  }

  freeze(account: AccountLeaf): void {
    account.setState(new FrozenState());
  }

  suspend(account: AccountLeaf): void {
    account.setState(new SuspendedState());
  }

  activate(account: AccountLeaf): void {
    // already active
  }

  close(account: AccountLeaf): void {
    account.setState(new ClosedState());
  }
}

./src/domain/accounts/state/ClosedState.ts
===== ./src/domain/accounts/state/ClosedState.ts =====

import { AccountState } from './AccountState';

export class ClosedState implements AccountState {
  name = 'CLOSED' as const;

  deposit(): void {
    throw new Error('Account is closed');
  }

  withdraw(): void {
    throw new Error('Account is closed');
  }

  freeze(): void {
    throw new Error('Account is closed');
  }

  suspend(): void {
    throw new Error('Account is closed');
  }

  activate(): void {
    throw new Error('Account is closed');
  }

  close(): void {
    // already closed
  }
}

./src/domain/accounts/state/FrozenState.ts
===== ./src/domain/accounts/state/FrozenState.ts =====
import type { AccountLeaf } from '../composite/AccountLeaf';
import { AccountState } from './AccountState';
import { ActiveState } from './ActiveState';
import { SuspendedState } from './SuspendedState';
import { ClosedState } from './ClosedState';

export class FrozenState implements AccountState {
  name = 'FROZEN' as const;

  deposit(account: AccountLeaf, amount: number): void {
    
    account.increaseBalance(amount);
  }

  withdraw(account: AccountLeaf, amount: number): void {
    throw new Error('Account is frozen: withdrawals are not allowed');
  }

  freeze(account: AccountLeaf): void {
    // already frozen
  }

  suspend(account: AccountLeaf): void {
    account.setState(new SuspendedState());
  }

  activate(account: AccountLeaf): void {
    account.setState(new ActiveState());
  }

  close(account: AccountLeaf): void {
    account.setState(new ClosedState());
  }
}

./src/domain/accounts/state/SuspendedState.ts
===== ./src/domain/accounts/state/SuspendedState.ts =====
// src/domain/accounts/state/SuspendedState.ts
import type { AccountLeaf } from '../composite/AccountLeaf';
import { AccountState } from './AccountState';
import { ActiveState } from './ActiveState';
import { ClosedState } from './ClosedState';

export class SuspendedState implements AccountState {
  name = 'SUSPENDED' as const;

  deposit(account: AccountLeaf, amount: number): void {
    throw new Error('Account is suspended: transactions are not allowed');
  }

  withdraw(account: AccountLeaf, amount: number): void {
    throw new Error('Account is suspended: transactions are not allowed');
  }

  freeze(account: AccountLeaf): void {
    throw new Error('Account is suspended: cannot freeze');
  }

  suspend(account: AccountLeaf): void {
    // already suspended
  }

  activate(account: AccountLeaf): void {
    account.setState(new ActiveState());
  }

  close(account: AccountLeaf): void {
    account.setState(new ClosedState());
  }
}

./src/domain/accounts/state.ts
===== ./src/domain/accounts/state.ts =====
export enum AccountStateAction {
  FREEZE = 'FREEZE',
  SUSPEND = 'SUSPEND',
  ACTIVATE = 'ACTIVATE',
  CLOSE = 'CLOSE',
}

./src/domain/accounts/types.ts
===== ./src/domain/accounts/types.ts =====
export type AccountType = 'SAVINGS' | 'CHECKING' | 'LOAN' | 'INVESTMENT'|'GROUP';

./src/domain/notifications/events.ts
===== ./src/domain/notifications/events.ts =====
export type AccountEventType =
  | 'ACCOUNT_CREATED'
  | 'ACCOUNT_STATE_CHANGED';

export type AccountEvent = {
  type: AccountEventType;
  at: Date;
  userId: number;

  accountId: number;
  accountName?: string;

  message: string;
};

./src/domain/notifications/observer.ts
===== ./src/domain/notifications/observer.ts =====
export interface Observer<E> {
  update(event: E): Promise<void> | void;
}

./src/domain/notifications/subject.ts
===== ./src/domain/notifications/subject.ts =====
import { Observer } from './observer';

export class Subject<E> {
  private observers: Observer<E>[] = [];

  subscribe(observer: Observer<E>) {
    this.observers.push(observer);
  }

  async notify(event: E) {
    // ملاحظة: نخليها sequential حتى لو SMS/Email فشل نعرف مين فشل
    for (const o of this.observers) {
      await o.update(event);
    }
  }
}

./src/domain/transactions/approval/ApprovalHandler.ts
===== ./src/domain/transactions/approval/ApprovalHandler.ts =====
import { TransactionType } from '@prisma/client';

export type TxRequest = {
  type: TransactionType;
  amount: number;
  requestedByRole: string;
};

export type ApprovalResult =
  | { approved: true; level: 'AUTO' | 'TELLER' | 'MANAGER' }
  | { approved: false; reason: string };

export abstract class ApprovalHandler {
  constructor(protected next?: ApprovalHandler) {}

  setNext(next: ApprovalHandler) {
    this.next = next;
    return next;
  }

  handle(req: TxRequest): ApprovalResult {
    const res = this.tryApprove(req);
    if (res) return res;
    if (!this.next) return { approved: false, reason: 'No approver available' };
    return this.next.handle(req);
  }

  protected abstract tryApprove(req: TxRequest): ApprovalResult | null;
}

./src/domain/transactions/approval/AutoApprove.ts
===== ./src/domain/transactions/approval/AutoApprove.ts =====
import { ApprovalHandler, TxRequest, ApprovalResult } from './ApprovalHandler';

export class AutoApprove extends ApprovalHandler {
  constructor(private maxAmount = 100) {
    super();
  }

  protected tryApprove(req: TxRequest): ApprovalResult | null {
    if (req.amount <= this.maxAmount) return { approved: true, level: 'AUTO' };
    return null;
  }
}

./src/domain/transactions/approval/ManagerApprove.ts
===== ./src/domain/transactions/approval/ManagerApprove.ts =====
import { ApprovalHandler, TxRequest, ApprovalResult } from './ApprovalHandler';

export class ManagerApprove extends ApprovalHandler {
  protected tryApprove(req: TxRequest): ApprovalResult | null {
    const ok = ['MANAGER', 'ADMIN'].includes(req.requestedByRole);
    if (ok) return { approved: true, level: 'MANAGER' };
    return null;
  }
}

./src/domain/transactions/approval/TellerApprove.ts
===== ./src/domain/transactions/approval/TellerApprove.ts =====
import { ApprovalHandler, TxRequest, ApprovalResult } from './ApprovalHandler';

export class TellerApprove extends ApprovalHandler {
  constructor(private maxAmount = 1000) {
    super();
  }

  protected tryApprove(req: TxRequest): ApprovalResult | null {
    const staff = ['TELLER', 'MANAGER', 'ADMIN'].includes(req.requestedByRole);
    if (staff && req.amount <= this.maxAmount) return { approved: true, level: 'TELLER' };
    return null;
  }
}

./src/infrastructure/auth/hash.ts
===== ./src/infrastructure/auth/hash.ts =====
import crypto from 'crypto';

export function sha256(input: string) {
  return crypto.createHash('sha256').update(input).digest('hex');
}

./src/infrastructure/auth/jwt.ts
===== ./src/infrastructure/auth/jwt.ts =====
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'dev_secret';
const ACCESS_EXPIRES_IN = process.env.JWT_ACCESS_EXPIRES_IN || '15m';
const REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '30d';

export type JwtPayload = { userId: number; role: string };

export function signAccessToken(payload: JwtPayload) {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: ACCESS_EXPIRES_IN });
}

export function signRefreshToken(payload: JwtPayload) {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: REFRESH_EXPIRES_IN });
}

export function verifyToken(token: string): JwtPayload {
  return jwt.verify(token, JWT_SECRET) as JwtPayload;
}

./src/infrastructure/mailer/mailer.ts
===== ./src/infrastructure/mailer/mailer.ts =====
import nodemailer from 'nodemailer';

export const mailer = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: Number(process.env.SMTP_PORT || 587),
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});

./src/infrastructure/prisma/client.ts
===== ./src/infrastructure/prisma/client.ts =====
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default prisma;

./src/infrastructure/prisma/seed.ts
===== ./src/infrastructure/prisma/seed.ts =====
import bcrypt from 'bcrypt';
import prisma from './client';

async function main() {
  const username = 'admin';
  const email = 'orangegames16@gmail.com';

  const existing = await prisma.user.findFirst({
    where: { OR: [{ username }, { email }] },
  });

  if (existing) {
    console.log('Admin already exists');
    return;
  }
const adminPass = process.env.ADMIN_PASSWORD!;

  const passwordHash = await bcrypt.hash(adminPass, 10);

  await prisma.user.create({
    data: {
      username,
      email,
      passwordHash,
      role: 'ADMIN',
      isEmailVerified: true, // مهم: خليه مفعل مباشرة
    },
  });

  console.log('Admin created ✅');
}

main().finally(() => prisma.$disconnect());

./src/infrastructure/scheduler/scheduled-runner.ts
===== ./src/infrastructure/scheduler/scheduled-runner.ts =====
import cron from "node-cron";
import prisma from "../prisma/client";
import { TransactionsService } from "../../application/services/transactions.service";
import { AccountRepo } from "../../repositories/account.repo";
import { TransactionRepo } from "../../repositories/transaction.repo";
import { buildNotificationCenter } from "../../application/notifications/notification.wiring";

const txService = new TransactionsService(new AccountRepo(), new TransactionRepo(), buildNotificationCenter());

function nextDate(freq: "DAILY" | "WEEKLY" | "MONTHLY", from: Date) {
  const d = new Date(from);
  if (freq === "DAILY") d.setDate(d.getDate() + 1);
  if (freq === "WEEKLY") d.setDate(d.getDate() + 7);
  if (freq === "MONTHLY") d.setMonth(d.getMonth() + 1);
  return d;
}

export function startScheduledRunner() {
  cron.schedule("* * * * *", async () => {
    const due = await prisma.scheduledTransaction.findMany({
      where: { isActive: true, nextRunAt: { lte: new Date() } },
    });

    for (const job of due) {
      try {
        await txService.create({
          type: job.type,
          amount: Number(job.amount),
          fromAccountId: job.fromAccountId ?? undefined,
          toAccountId: job.toAccountId ?? undefined,
          requester: { userId: job.createdById, role: "CUSTOMER" },
        });

        await prisma.scheduledTransaction.update({
          where: { id: job.id },
          data: { nextRunAt: nextDate(job.frequency as any, job.nextRunAt) },
        });
      } catch (e) {
        await prisma.eventLog.create({
          data: {
            userId: job.createdById,
            eventType: "SCHEDULED_TX_FAILED",
            details: { scheduledId: job.id, error: String(e) },
          },
        });
      }
    }
  });
}

./src/landingpage.ts
===== ./src/landingpage.ts =====
import type { Request, Response } from 'express';

 export const getLandingPage = (_req: Request, res: Response) => {
  res
    .status(200)
    .set('Cache-Control', 'no-store')
    .type('html')
    .send(`
      <!doctype html>
      <html lang="en">
        <head>
          <meta charset="utf-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <title>${process.env.APP_NAME || 'Banking API'}</title>
          <style>
            body{font-family:system-ui,-apple-system,Segoe UI,Roboto;max-width:920px;margin:44px auto;padding:0 16px;line-height:1.6}
            .card{border:1px solid #e8e8e8;border-radius:14px;padding:18px;box-shadow:0 2px 10px rgba(0,0,0,.04)}
            code{background:#f4f4f4;padding:2px 6px;border-radius:6px}
            .muted{color:#666}
            ul{margin:10px 0 0 18px}
            .row{display:flex;gap:12px;flex-wrap:wrap}
            .pill{border:1px solid #e8e8e8;border-radius:999px;padding:6px 10px;font-size:14px}
          </style>
        </head>
        <body>
          <h1>${process.env.APP_NAME || 'Banking API'}</h1>
          <p class="muted">Secure backend service for banking operations.</p>

          <div class="card">
            <div class="row">
              <span class="pill"><b>Status:</b> Online ✅</span>
              <span class="pill"><b>Version:</b> ${process.env.APP_VERSION || '1.0.0'}</span>
              <span class="pill"><b>Environment:</b> ${process.env.NODE_ENV || 'development'}</span>
            </div>

            <hr style="border:none;border-top:1px solid #eee;margin:16px 0" />

            <p><b>Available routes</b></p>
            <ul>
              <li><code>/api</code> — API routes (protected where applicable)</li>
              <li><code>/health</code> — service health check</li>
            </ul>

            <p class="muted" style="margin-top:14px">
              Note: Detailed system information is intentionally not exposed on the public landing page.
            </p>
          </div>
        </body>
      </html>
    `);
};

./src/repositories/account.repo.ts
===== ./src/repositories/account.repo.ts =====
import prisma from '../infrastructure/prisma/client';
import { AccountMapper } from '../application/mappers/account.mapper';
import { AccountComponent } from '../domain/accounts/composite/AccountComponent';
import { AccountLeaf } from '../domain/accounts/composite/AccountLeaf';
import { AccountState, AccountType } from '@prisma/client';

import { applyDecorators } from '../domain/accounts/decorator/applyDecorators';
import { unwrapToBase } from '../domain/accounts/decorator/unwrap';

export class AccountRepo {
  // original (non-decorated) read
  async findById(id: number): Promise<AccountComponent | null> {
    const dbAcc = await prisma.account.findUnique({
      where: { id },
      include: { subAccounts: true }
    });
    if (!dbAcc) return null;
    return AccountMapper.toDomain(dbAcc);
  }

  // decorated read (applies features stored in DB)
  async findByIdDecorated(id: number): Promise<AccountComponent | null> {
    const dbAcc = await prisma.account.findUnique({
      where: { id },
      include: { subAccounts: true, features: true }
    });
    if (!dbAcc) return null;

    const domain = AccountMapper.toDomain(dbAcc as any);
    if (dbAcc.accountType === 'GROUP') return domain;

    const features = (dbAcc.features ?? []).map((f: any) => ({
      type: f.type,
      numberValue: f.numberValue ? Number(f.numberValue) : null
    }));

    return applyDecorators(domain, features);
  }

  async save(account: AccountComponent): Promise<void> {
    const raw: any = unwrapToBase(account as any);

    const data: any = {
      balance: AccountMapper.balanceToDbDecimal(account.getBalance()),
    };

    if (raw instanceof AccountLeaf) {
      data.state = raw.getState() as AccountState;
    }

    await prisma.account.update({
      where: { id: Number(account.getId()) },
      data
    });
  }

  async create(data: any) {
    const dbAccount = await prisma.account.create({ data });
    return AccountMapper.toDomain(dbAccount);
  }

  async createGroup(params: { userId: number; name: string }) {
    const dbAccount = await prisma.account.create({
      data: {
        userId: params.userId,
        accountType: 'GROUP',
        balance: 0,
        state: 'ACTIVE',
        name: params.name
      },
    });
    return AccountMapper.toDomain(dbAccount);
  }

  async setParent(childId: number, parentId: number) {
    await prisma.account.update({
      where: { id: childId },
      data: { parentAccountId: parentId },
    });
  }

  async removeParent(childId: number) {
    await prisma.account.update({
      where: { id: childId },
      data: { parentAccountId: null },
    });
  }

  async findManyByUserId(userId: number): Promise<AccountComponent[]> {
    const list = await prisma.account.findMany({
      where: { userId, parentAccountId: null },
      include: { subAccounts: true, features: true }
    });

    return list.map(dbAcc => {
      const domain = AccountMapper.toDomain(dbAcc as any);
      if (dbAcc.accountType === 'GROUP') return domain;

      const features = (dbAcc.features ?? []).map((f: any) => ({
        type: f.type,
        numberValue: f.numberValue ? Number(f.numberValue) : null
      }));

      return applyDecorators(domain, features);
    });
  }

  async search(filters: {
    userId?: number;
    accountType?: AccountType;
    state?: string;
    minBalance?: number;
    maxBalance?: number;
  }) {
    const where: any = {};

    if (filters.userId) where.userId = filters.userId;
    if (filters.accountType) where.accountType = filters.accountType;
    if (filters.state) where.state = filters.state;

    if (filters.minBalance !== undefined || filters.maxBalance !== undefined) {
      where.balance = {};
      if (filters.minBalance !== undefined) where.balance.gte = filters.minBalance;
      if (filters.maxBalance !== undefined) where.balance.lte = filters.maxBalance;
    }

    const accounts = await prisma.account.findMany({
      where,
      include: { user: { select: { username: true, email: true } } },
    });

    return accounts.map(acc => ({
      id: acc.id,
      type: acc.accountType,
      balance: Number(acc.balance),
      state: acc.state,
      user: acc.user,
    }));
  }

  async getOwnerUserIdByAccountId(accountId: number): Promise<number> {
    const acc = await prisma.account.findUnique({
      where: { id: accountId },
      select: { userId: true },
    });
    if (!acc) throw new Error('Account not found');
    return acc.userId;
  }

  // ---- features (Decorator persistence) ----
  async addFeature(accountId: number, type: any, numberValue?: number) {
    const { Prisma } = require('@prisma/client');
    return prisma.accountFeature.upsert({
      where: { accountId_type: { accountId, type } },
      update: { numberValue: numberValue !== undefined ? new Prisma.Decimal(numberValue) : undefined },
      create: {
        accountId,
        type,
        numberValue: numberValue !== undefined ? new Prisma.Decimal(numberValue) : undefined,
      },
    });
  }

  async removeFeature(accountId: number, type: any) {
    return prisma.accountFeature.delete({
      where: { accountId_type: { accountId, type } },
    });
  }
}

./src/repositories/admin.repo.ts
===== ./src/repositories/admin.repo.ts =====
import prisma from "../infrastructure/prisma/client";
import { Prisma } from "@prisma/client";

function startOfDay(d: Date) {
  const x = new Date(d);
  x.setHours(0, 0, 0, 0);
  return x;
}
function endOfDay(d: Date) {
  const x = new Date(d);
  x.setHours(23, 59, 59, 999);
  return x;
}

export class AdminRepo {
  async dashboard() {
    const now = new Date();

    const todayStart = startOfDay(now);
    const todayEnd = endOfDay(now);

    const weekStart = new Date(now);
    weekStart.setDate(now.getDate() - 7);

    const monthStart = new Date(now);
    monthStart.setDate(now.getDate() - 30);

    const [
      usersByRole,
      accountsByType,
      accountsByState,
      txTodayCount,
      txWeekCount,
      txMonthCount,
      pendingTxCount,
      txTodayCompletedSum,
      ticketsByStatus,
      activeScheduledCount,
      recentEvents,
    ] = await Promise.all([
      prisma.user.groupBy({ by: ["role"], _count: { _all: true } }),
      prisma.account.groupBy({ by: ["accountType"], _count: { _all: true } }),
      prisma.account.groupBy({ by: ["state"], _count: { _all: true } }),

      prisma.transaction.count({ where: { createdAt: { gte: todayStart, lte: todayEnd } } }),
      prisma.transaction.count({ where: { createdAt: { gte: weekStart } } }),
      prisma.transaction.count({ where: { createdAt: { gte: monthStart } } }),

      prisma.transaction.count({ where: { status: "PENDING" } }),
      prisma.transaction.aggregate({
        where: { status: "COMPLETED", createdAt: { gte: todayStart, lte: todayEnd } },
        _sum: { amount: true },
      }),

      prisma.ticket.groupBy({ by: ["status"], _count: { _all: true } }),
      prisma.scheduledTransaction.count({ where: { isActive: true } }),

      prisma.eventLog.findMany({
        orderBy: { createdAt: "desc" },
        take: 10,
        include: { user: { select: { id: true, username: true, role: true } } },
      }),
    ]);

    return {
      usersByRole,
      accountsByType,
      accountsByState,
      transactions: {
        today: txTodayCount,
        last7Days: txWeekCount,
        last30Days: txMonthCount,
        pending: pendingTxCount,
        todayCompletedAmountSum: Number(txTodayCompletedSum._sum.amount ?? 0),
      },
      ticketsByStatus,
      activeScheduledCount,
      recentEvents,
      generatedAt: now,
    };
  }

  async dailyTransactionsReport(date: Date) {
    const from = startOfDay(date);
    const to = endOfDay(date);

    const [byStatus, byType, completedSum, list] = await Promise.all([
      prisma.transaction.groupBy({
        by: ["status"],
        where: { createdAt: { gte: from, lte: to } },
        _count: { _all: true },
      }),
      prisma.transaction.groupBy({
        by: ["type"],
        where: { createdAt: { gte: from, lte: to } },
        _count: { _all: true },
      }),
      prisma.transaction.aggregate({
        where: { status: "COMPLETED", createdAt: { gte: from, lte: to } },
        _sum: { amount: true },
      }),
      prisma.transaction.findMany({
        where: { createdAt: { gte: from, lte: to } },
        orderBy: { createdAt: "desc" },
        take: 200,
        include: {
          fromAccount: { select: { id: true, name: true, userId: true } },
          toAccount: { select: { id: true, name: true, userId: true } },
          approvedBy: { select: { id: true, username: true, role: true } },
        },
      }),
    ]);

    return {
      date: from.toISOString().slice(0, 10),
      totals: {
        byStatus,
        byType,
        completedAmountSum: Number(completedSum._sum.amount ?? 0),
      },
      transactions: list.map((t) => ({
        id: t.id,
        type: t.type,
        status: t.status,
        amount: Number(t.amount),
        createdAt: t.createdAt,
        fromAccount: t.fromAccount,
        toAccount: t.toAccount,
        approvedBy: t.approvedBy,
      })),
    };
  }

  async accountsSummaryReport(filters: { userId?: number; type?: string; state?: string }) {
    const where: Prisma.AccountWhereInput = {};
    if (filters.userId) where.userId = filters.userId;
    if (filters.type) where.accountType = filters.type as any;
    if (filters.state) where.state = filters.state as any;

    const [count, byType, topAccounts] = await Promise.all([
      prisma.account.count({ where }),
      prisma.account.groupBy({
        by: ["accountType"],
        where,
        _count: { _all: true },
        _sum: { balance: true },
      }),
      prisma.account.findMany({
        where,
        orderBy: { balance: "desc" },
        take: 10,
        select: { id: true, userId: true, name: true, accountType: true, state: true, balance: true },
      }),
    ]);

    return {
      totalAccounts: count,
      byType: byType.map((x) => ({
        accountType: x.accountType,
        count: x._count._all,
        totalBalance: Number(x._sum.balance ?? 0),
      })),
      topAccounts: topAccounts.map((a) => ({
        ...a,
        balance: Number(a.balance),
      })),
    };
  }

  async auditReport(filters: { from?: Date; to?: Date; userId?: number; eventType?: string }) {
    const where: Prisma.EventLogWhereInput = {};
    if (filters.userId) where.userId = filters.userId;
    if (filters.eventType) where.eventType = filters.eventType;

    if (filters.from || filters.to) {
      where.createdAt = {};
      if (filters.from) (where.createdAt as any).gte = filters.from;
      if (filters.to) (where.createdAt as any).lte = filters.to;
    }

    const list = await prisma.eventLog.findMany({
      where,
      orderBy: { createdAt: "desc" },
      take: 500,
      include: {
        user: { select: { id: true, username: true, role: true } },
        account: { select: { id: true, name: true } },
        transaction: { select: { id: true, type: true, status: true, amount: true } },
      },
    });

    return list.map((e) => ({
      id: e.id,
      eventType: e.eventType,
      createdAt: e.createdAt,
      details: e.details,
      user: e.user,
      account: e.account,
      transaction: e.transaction ? { ...e.transaction, amount: Number(e.transaction.amount) } : null,
    }));
  }
}

./src/repositories/emailVerification.repo.ts
===== ./src/repositories/emailVerification.repo.ts =====
import prisma from '../infrastructure/prisma/client';

export class EmailVerificationRepo {
  create(email: string, codeHash: string, expiresAt: Date) {
    return prisma.emailVerification.create({ data: { email, codeHash, expiresAt } });
  }

  findValid(email: string, codeHash: string) {
    return prisma.emailVerification.findFirst({
      where: { email, codeHash, usedAt: null, expiresAt: { gt: new Date() } },
      orderBy: { createdAt: 'desc' },
    });
  }

  markUsed(id: number) {
    return prisma.emailVerification.update({ where: { id }, data: { usedAt: new Date() } });
  }
}

./src/repositories/event.repo.ts
===== ./src/repositories/event.repo.ts =====
import prisma from "../infrastructure/prisma/client";

export class EventRepo {
  listForUser(userId: number, take = 100) {
    return prisma.eventLog.findMany({
      where: { userId },
      orderBy: { createdAt: "desc" },
      take,
    });
  }

  listAll(filters?: { userId?: number }, take = 200) {
    return prisma.eventLog.findMany({
      where: { ...(filters?.userId ? { userId: filters.userId } : {}) },
      orderBy: { createdAt: "desc" },
      take,
    });
  }
}

./src/repositories/notification.repo.ts
===== ./src/repositories/notification.repo.ts =====
import { NotificationChannel, NotificationStatus, Prisma } from "@prisma/client";
import prisma from "../infrastructure/prisma/client";

export class NotificationRepo {
  async create(data: {
    userId: number;
    relatedAccountId?: number;
    relatedTransactionId?: number;
    channel: NotificationChannel;
    message: string;
    status?: NotificationStatus;
  }) {
    return prisma.notification.create({
      data: {
        userId: data.userId,
        relatedAccountId: data.relatedAccountId,
        relatedTransactionId: data.relatedTransactionId,
        channel: data.channel,
        message: data.message,
        status: data.status ?? "PENDING",
      },
    });
  }

  async listByUser(userId: number, take = 50) {
    return prisma.notification.findMany({
      where: { userId },
      orderBy: { createdAt: "desc" },
      take,
    });
  }

  async markRead(userId: number, id: number) {
    return prisma.notification.updateMany({
      where: { id, userId, readAt: null },
      data: { readAt: new Date() },
    });
  }
}

./src/repositories/refreshToken.repo.ts
===== ./src/repositories/refreshToken.repo.ts =====
import prisma from '../infrastructure/prisma/client';

export class RefreshTokenRepo {
  create(userId: number, tokenHash: string, expiresAt: Date) {
    return prisma.refreshToken.create({ data: { userId, tokenHash, expiresAt } });
  }

  findValid(tokenHash: string) {
    return prisma.refreshToken.findFirst({
      where: { tokenHash, revokedAt: null, expiresAt: { gt: new Date() } },
      include: { user: true },
    });
  }

  revokeByHash(tokenHash: string) {
    return prisma.refreshToken.updateMany({
      where: { tokenHash, revokedAt: null },
      data: { revokedAt: new Date() },
    });
  }
}

./src/repositories/scheduledTransaction.repo.ts
===== ./src/repositories/scheduledTransaction.repo.ts =====
import prisma from "../infrastructure/prisma/client";
import { Prisma, TransactionType, Frequency } from "@prisma/client";

export class ScheduledTransactionRepo {
  create(input: {
    createdById: number;
    fromAccountId?: number;
    toAccountId?: number;
    amount: number;
    type: TransactionType;
    frequency: Frequency;
    nextRunAt: Date;
  }) {
    const amountDec = new Prisma.Decimal(input.amount);
    return prisma.scheduledTransaction.create({
      data: {
        createdById: input.createdById,
        fromAccountId: input.fromAccountId ?? null,
        toAccountId: input.toAccountId ?? null,
        amount: amountDec,
        type: input.type,
        frequency: input.frequency,
        nextRunAt: input.nextRunAt,
      },
    });
  }

  listByUser(createdById: number) {
    return prisma.scheduledTransaction.findMany({
      where: { createdById },
      orderBy: { createdAt: "desc" },
    });
  }

  stop(createdById: number, id: number) {
    return prisma.scheduledTransaction.updateMany({
      where: { id, createdById },
      data: { isActive: false },
    });
  }

  resume(createdById: number, id: number) {
    return prisma.scheduledTransaction.updateMany({
      where: { id, createdById },
      data: { isActive: true },
    });
  }

  listDue() {
    return prisma.scheduledTransaction.findMany({
      where: { isActive: true, nextRunAt: { lte: new Date() } },
    });
  }

  updateNextRun(id: number, nextRunAt: Date) {
    return prisma.scheduledTransaction.update({ where: { id }, data: { nextRunAt } });
  }
}

./src/repositories/ticket.repo.ts
===== ./src/repositories/ticket.repo.ts =====
import prisma from "../infrastructure/prisma/client";
import { TicketStatus } from "@prisma/client";

export class TicketRepo {
  create(data: { userId: number; subject: string; description: string }) {
    return prisma.ticket.create({ data });
  }

  listForUser(userId: number) {
    return prisma.ticket.findMany({ where: { userId }, orderBy: { createdAt: "desc" } });
  }

  listAll() {
    return prisma.ticket.findMany({ orderBy: { createdAt: "desc" }, include: { user: { select: { id: true, username: true, email: true } } } });
  }

  updateStatus(id: number, status: TicketStatus) {
    return prisma.ticket.update({ where: { id }, data: { status } });
  }
}

./src/repositories/transaction.repo.ts
===== ./src/repositories/transaction.repo.ts =====
import prisma from "../infrastructure/prisma/client";
import { Prisma, TransactionStatus } from "@prisma/client";

export class TransactionRepo {
  async atomicApplyAndMark(params: {
    txId: number;
    status: TransactionStatus;
    approvedById?: number | null;
    fromAccountId?: number;
    toAccountId?: number;
    fromNewBalance?: Prisma.Decimal;
    toNewBalance?: Prisma.Decimal;
  }) {
    return prisma.$transaction(async (tx) => {
      if (params.fromAccountId && params.fromNewBalance) {
        await tx.account.update({ where: { id: params.fromAccountId }, data: { balance: params.fromNewBalance } });
      }
      if (params.toAccountId && params.toNewBalance) {
        await tx.account.update({ where: { id: params.toAccountId }, data: { balance: params.toNewBalance } });
      }

      await tx.transaction.update({
        where: { id: params.txId },
        data: {
          status: params.status,
          approvedById: params.approvedById ?? null,
        },
      });
    });
  }

  pending() {
    return prisma.transaction.findMany({
      where: { status: "PENDING" },
      orderBy: { createdAt: "asc" },
    });
  }
}

./src/repositories/user.repo.ts
===== ./src/repositories/user.repo.ts =====
import prisma from '../infrastructure/prisma/client';
import { Prisma } from '@prisma/client';

export class UserRepo {
  create(data: Prisma.UserCreateInput) {
    return prisma.user.create({ data });
  }

  findById(id: number) {
    return prisma.user.findUnique({ where: { id } });
  }

  findByUsername(username: string) {
    return prisma.user.findUnique({ where: { username } });
  }

  findByEmail(email: string) {
    return prisma.user.findUnique({ where: { email } });
  }

  setEmailVerified(id: number) {
    return prisma.user.update({ where: { id }, data: { isEmailVerified: true } });
  }
}

./src/server.ts
===== ./src/server.ts =====
import app from './app';
import { startScheduledRunner } from './infrastructure/scheduler/scheduled-runner';

const PORT = process.env.PORT || 3000;

startScheduledRunner();

const server = app.listen(Number(PORT), "0.0.0.0",() => {
  console.log(`🚀 Server running on port ${PORT}`);
});

process.on('SIGINT', () => {
  console.log('🔻 Shutting down...');
  server.close(() => process.exit(0));
});

./src/types/jsonwebtoken.d.ts
===== ./src/types/jsonwebtoken.d.ts =====
declare module 'jsonwebtoken' {
  export type Secret =
    | string
    | Buffer
    | { key: string | Buffer; passphrase: string };

  export interface SignOptions {
    expiresIn?: string | number;
  }

  export interface VerifyOptions {
    // Add fields as needed; kept minimal for current usage.
  }

  export type JwtPayload = { [key: string]: any };

  export function sign(
    payload: string | object | Buffer,
    secretOrPrivateKey: Secret,
    options?: SignOptions
  ): string;

  export function verify(
    token: string,
    secretOrPublicKey: Secret,
    options?: VerifyOptions
  ): string | JwtPayload;

  const jwt: {
    sign: typeof sign;
    verify: typeof verify;
  };

  export default jwt;
}

./src/__tests__/accounts/account.domain.test.ts
===== ./src/__tests__/accounts/account.domain.test.ts =====
import { SavingsAccount } from "../../domain/accounts/composite/SavingsAccount";
import { CheckingAccount } from "../../domain/accounts/composite/CheckingAccount";
import { AccountGroup } from "../../domain/accounts/composite/AccountGroup";
import { ActiveState } from "../../domain/accounts/state/ActiveState";
import { FrozenState } from "../../domain/accounts/state/FrozenState";
import { PremiumServiceDecorator } from "../../domain/accounts/decorator/PremiumServiceDecorator";
import { InsuranceDecorator } from "../../domain/accounts/decorator/InsuranceDecorator";
import { OverdraftDecorator } from "../../domain/accounts/decorator/OverdraftDecorator";

describe("Accounts Domain (Composite + State + Decorator)", () => {
  test("Savings deposit/withdraw works in ACTIVE", () => {
    const acc = new SavingsAccount("1", "sav", 100, new ActiveState());
    acc.deposit(50);
    expect(acc.getBalance()).toBe(150);
    acc.withdraw(20);
    expect(acc.getBalance()).toBe(130);
  });

  test("Frozen blocks withdraw", () => {
    const acc = new SavingsAccount("1", "sav", 100, new FrozenState());
    expect(() => acc.withdraw(10)).toThrow();
  });

  test("Composite group sums children balances", () => {
    const g = new AccountGroup("g1", "group");
    const a1 = new SavingsAccount("1", "a1", 50, new ActiveState());
    const a2 = new SavingsAccount("2", "a2", 70, new ActiveState());
    g.add(a1);
    g.add(a2);
    expect(g.getBalance()).toBe(120);
  });

  test("Decorator: Premium adds cashback on deposit", () => {
    const base = new SavingsAccount("1", "sav", 0, new ActiveState());
    const premium = new PremiumServiceDecorator(base as any, 0.1);
    premium.deposit(100);
    expect(premium.getBalance()).toBe(110);
  });

  test("Decorator: Insurance charges fee on withdraw", () => {
    const base = new SavingsAccount("1", "sav", 100, new ActiveState());
    const insured = new InsuranceDecorator(base as any, 2);
    insured.withdraw(10);
    expect(insured.getBalance()).toBe(88);
  });

  test("Decorator: Overdraft increases checking limit", () => {
    const chk = new CheckingAccount("1", "chk", 0, 0, new ActiveState());
    new OverdraftDecorator(chk, 100);
    chk.withdraw(50);
    expect(chk.getBalance()).toBe(-50);
  });
});

./src/__tests__/events/events.service.test.ts
===== ./src/__tests__/events/events.service.test.ts =====
import { EventsService } from "../../application/services/events.service";
import { EventRepo } from "../../repositories/event.repo";

describe("EventsService", () => {
  test("Customer can only list own events", async () => {
    jest.spyOn(EventRepo.prototype, "listForUser").mockResolvedValue([{ id: 1 }] as any);
    const s = new EventsService();
    const out = await s.list({ userId: 10, role: "CUSTOMER" });
    expect(out).toEqual([{ id: 1 }]);
  });

  test("Staff can list all events", async () => {
    jest.spyOn(EventRepo.prototype, "listAll").mockResolvedValue([{ id: 2 }] as any);
    const s = new EventsService();
    const out = await s.list({ userId: 10, role: "ADMIN" }, { userId: 99 });
    expect(out).toEqual([{ id: 2 }]);
  });
});

./src/__tests__/mocks/prisma.mock.ts
===== ./src/__tests__/mocks/prisma.mock.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */

// مهم: لازم يكون jest متاح (ببيئة Jest هو global)
type AnyFn = (...args: any[]) => any;

export const prismaMock: any = {};

prismaMock.account = {
  findUnique: jest.fn(),
  update: jest.fn(),
  findMany: jest.fn(),
  create: jest.fn(),
  groupBy: jest.fn(),
  count: jest.fn(),
  aggregate: jest.fn(),
};

prismaMock.accountFeature = {
  upsert: jest.fn(),
  delete: jest.fn(),
};

prismaMock.transaction = {
  create: jest.fn(),
  findUnique: jest.fn(),
  update: jest.fn(),
  findMany: jest.fn(),
  count: jest.fn(),
  groupBy: jest.fn(),
  aggregate: jest.fn(),
};

prismaMock.scheduledTransaction = {
  create: jest.fn(),
  findMany: jest.fn(),
  update: jest.fn(),
  updateMany: jest.fn(),
  count: jest.fn(),
};

prismaMock.eventLog = {
  create: jest.fn(),
  findMany: jest.fn(),
};

prismaMock.ticket = {
  groupBy: jest.fn(),
};

prismaMock.user = {
  groupBy: jest.fn(),
  findUnique: jest.fn(),
  findMany: jest.fn(),
};

prismaMock.notification = {
  create: jest.fn(),
  findMany: jest.fn(),
  updateMany: jest.fn(),
};

// transaction helper: ينفذ callback ويمرر prismaMock كـ tx
prismaMock.$transaction = jest.fn(async (cb: AnyFn) => cb(prismaMock));


./src/__tests__/scheduled/scheduled.service.test.ts
===== ./src/__tests__/scheduled/scheduled.service.test.ts =====
import { ScheduledTransactionsService } from "../../application/services/scheduledTransactions.service";
import prisma from "../../infrastructure/prisma/client";

describe("ScheduledTransactionsService", () => {
  test("create validates required account ids by type", async () => {
    const s = new ScheduledTransactionsService();
    await expect(s.create({ userId: 1 }, {
      type: "TRANSFER" as any,
      amount: 10,
      frequency: "DAILY" as any,
      nextRunAt: new Date().toISOString(),
    } as any)).rejects.toThrow();
  });

  test("create rejects scheduling for accounts not owned by user", async () => {
    const s = new ScheduledTransactionsService();
    (prisma as any).account.findMany.mockResolvedValue([{ id: 5, userId: 999 }]);

    await expect(s.create({ userId: 1 }, {
      type: "DEPOSIT" as any,
      amount: 10,
      toAccountId: 5,
      frequency: "DAILY" as any,
      nextRunAt: new Date().toISOString(),
    })).rejects.toThrow("You can only schedule for your own accounts");
  });
});

./src/__tests__/setup.ts
===== ./src/__tests__/setup.ts =====
import { prismaMock } from "./mocks/prisma.mock";

jest.mock("../infrastructure/prisma/client", () => ({
  __esModule: true,
  default: prismaMock,
}));

beforeEach(() => {
  jest.clearAllMocks();
});

./src/__tests__/transactions/transactions.service.test.ts
===== ./src/__tests__/transactions/transactions.service.test.ts =====
import { TransactionsService } from "../../application/services/transactions.service";
import { AccountRepo } from "../../repositories/account.repo";
import { TransactionRepo } from "../../repositories/transaction.repo";
import { NotificationCenter } from "../../application/notifications/notification-center";
import { ActiveState } from "../../domain/accounts/state/ActiveState";
import { CheckingAccount } from "../../domain/accounts/composite/CheckingAccount";
import prisma from "../../infrastructure/prisma/client";

describe("TransactionsService", () => {
  function mkService() {
    const accounts = new AccountRepo();
    const txRepo = new TransactionRepo();
    const notifications = new NotificationCenter();
    jest.spyOn(notifications, "notify").mockResolvedValue(undefined as any);
    return { service: new TransactionsService(accounts, txRepo, notifications) };
  }

  test("AUTO approve small deposit => COMPLETED + event TX_COMPLETED", async () => {
    const { service } = mkService();

    const toAcc = new CheckingAccount("10", "to", 0, 0, new ActiveState());
    jest.spyOn(AccountRepo.prototype, "findByIdDecorated").mockResolvedValue(toAcc as any);

    (prisma as any).transaction.create.mockResolvedValue({
      id: 1, amount: 50, type: "DEPOSIT", status: "COMPLETED", fromAccountId: null, toAccountId: 10
    });

    jest.spyOn(TransactionRepo.prototype, "atomicApplyAndMark").mockResolvedValue(undefined as any);
    (prisma as any).eventLog.create.mockResolvedValue({ id: 99 });

    const out = await service.create({
      type: "DEPOSIT" as any,
      amount: 50,
      toAccountId: 10,
      requester: { userId: 7, role: "CUSTOMER" },
    });

    expect(out.approval.approved).toBe(true);
    expect((prisma as any).eventLog.create).toHaveBeenCalledWith(expect.objectContaining({
      data: expect.objectContaining({ eventType: "TX_COMPLETED" }),
    }));
  });

  test("Large deposit by CUSTOMER => PENDING + event TX_PENDING", async () => {
    const { service } = mkService();

    (prisma as any).transaction.create.mockResolvedValue({
      id: 2, amount: 5000, type: "DEPOSIT", status: "PENDING", fromAccountId: null, toAccountId: 10
    });

    (prisma as any).eventLog.create.mockResolvedValue({ id: 100 });

    const out = await service.create({
      type: "DEPOSIT" as any,
      amount: 5000,
      toAccountId: 10,
      requester: { userId: 7, role: "CUSTOMER" },
    });

    expect(out.approval.approved).toBe(false);
    expect((prisma as any).eventLog.create).toHaveBeenCalledWith(expect.objectContaining({
      data: expect.objectContaining({ eventType: "TX_PENDING" }),
    }));
  });
});

./tsconfig.json
===== ./tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "rootDir": "./src",
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true
  },
  "include": ["src"]
}

